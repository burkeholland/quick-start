<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>NativeScript Quick Start</title>

	<meta charset="utf-8">
	<meta name="description" content="A quick-start guide for NativeScript CLI apps">
	<meta name="author" content="TJ VanToll, Jen Looper">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="header">
	<a href="#" class="menu header-btn" id="toggle-toc"></a>
	<h1>NativeScript Quick Start</h1>
	<a href="https://github.com/tjvantoll/nativescript-quick-start" class="github header-btn"></a>
</div>

<div id="container">
	<div id="toc">
		<div class="author">By <a href="http://tjvantoll.com">@tjvantoll</a>, <a href="http://www.ladeezfirstmedia.com">@jenlooper</a></div>
		<div id="toc-padding"></div>
	</div>
	<div id="book">
		<div class="chapter">
			<h2 id="introduction">Introduction</h2>
<p>Welcome to the <a href="https://nativescript.org">NativeScript</a> Getting Started Guide. Using this guide, you&#39;ll use NativeScript, a cross-platform JavaScript framework for building native mobile apps, to build an iOS and Android app from scratch.</p>
<p><img src="images/nativescript-logo.jpg" alt="NativeScript.org logo"></p>
<h3 id="what-you-re-building">What you&#39;re building</h3>
<p>Here&#39;s the premise: your boss has tasked you with creating the next great grocery management app. You&#39;re given some designs from your design team, a few HTTP endpoints from your backend team, and you&#39;re told to build an app that does the following things:</p>
<ul>
<li>Allows users to register and login.</li>
<li>Allows authenticated users to add and delete groceries from a list.</li>
<li>Connects to your companies&#39; existing RESTful services.</li>
<li>Meets your design team&#39;s “native” mockups.</li>
<li>Runs cross-platform—i.e. iOS and Android.</li>
<li>Runs cross-device—i.e. phones and tablets.</li>
</ul>
<p>This guide will walk you through building an app that meets these requirements and more. If you follow along to the end here&#39;s what the finished app looks like on iOS:</p>
<p><img src="images/login-screenshot.png" alt="login">
<img src="images/register-screenshot.png" alt="register">
<img src="images/list-screenshot.png" alt="list"></p>
<p>And here&#39;s what the app looks like on Android:</p>
<p><img src="images/screenshot-placeholder.png" alt="placeholder">
<img src="images/screenshot-placeholder.png" alt="placeholder">
<img src="images/screenshot-placeholder.png" alt="placeholder"></p>
<p>By building “Groceries“ you&#39;ll see just how easy NativeScript makes building iOS and Android apps—and fun too! Let&#39;s get started.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="getting-up-and-running">Getting up and running</h2>
<p>There are two ways to use NativeScript: through the NativeScript Command-Line Interface (CLI) and through <a href="http://www.telerik.com/appbuilder">Telerik AppBuilder</a>. Although the NativeScript framework itself is the same regardless of whether you use the CLI or AppBuilder, the way you interface with NativeScript—how you run your app, how you change configuration files, and so forth—differs based on the interface you choose.</p>
<p>For this guide, we&#39;re assuming that you are going to develop your app on your local computer using the NativeScript CLI. Although most of the steps and advice given in this guide apply equally to using NativeScript through the CLI or AppBuilder, some—mostly related to development workflow—are specific to using NativeScript through the NativeScript CLI.</p>
<h3 id="install-nativescript-and-configure-your-environment">Install NativeScript and configure your environment</h3>
<p>The NativeScript CLI has a few system requirements you must complete before building NativeScript apps. As a first step start by going through the appropriate instructions below depending on your development machine&#39;s operating system:</p>
<ul>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-win.html">Windows</a></li>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-os-x.html">OS X</a></li>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-linux.html">Linux</a></li>
</ul>
<p>Once you have the setup complete, use the <code>npm install</code> command to install the NativeScript CLI itself:</p>
<pre><code>$ npm install -g nativescript
</code></pre><p>You should now have two commands available from your terminal: <code>tns</code>—which is short for <strong>T</strong>elerik <strong>N</strong>ative<strong>S</strong>cript—and <code>nativescript</code>. The two commands are equivalent, so we&#39;ll stick with the shorter <code>tns</code> command throughout this guide.</p>
<p>You can verify the installation was successful by running <code>tns</code> in your terminal. You should see something like this:</p>
<pre><code>$ tns
# NativeScript
┌─────────┬─────────────────────────────────────────────────────────────────────┐
│ Usage   │ Synopsis                                                            │
│ General │ $ tns &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;]          │
│ Alias   │ $ nativescript &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;] │
└─────────┴─────────────────────────────────────────────────────────────────────┘
</code></pre><h3 id="start-your-app">Start your app</h3>
<p>With NativeScript CLI installed, it&#39;s time to start your app. You normally use the <code>tns create</code> command to create new apps—e.g. <code>tns create hello-world</code>—but for this guide we&#39;re scaffolded out a boilerplate project to act as a starting point for Groceries. To get it, navigate to a folder where you want to keep your app&#39;s code and clone the Groceries repo:</p>
<pre><code>$ cd folder-you-want-groceries-to-be-in
$ git clone https://github.com/tjvantoll/groceries.git
$ cd groceries
</code></pre><p>The master branch has the final state of the Groceries app. Feel free to refer back to it at any time, but for now switch over to the “start” branch for the guide&#39;s starting point:</p>
<pre><code>$ git checkout start
</code></pre><h3 id="add-target-development-platforms">Add target development platforms</h3>
<p>Your project is now setup, but before you run it you have to do a little iOS- and Android-specific configuration using the <code>tns platform add</code> command. Start by adding the Android platform:</p>
<pre><code>$ tns platform add android
</code></pre><p>And if you&#39;re on a Mac add the iOS platform next:</p>
<pre><code>$ tns platform add ios
</code></pre><p>The <code>platform add</code> command uses the native SDKs to initialize platform-specific projects and places the generated contents in your app&#39;s <code>platforms</code> folder. Later on, the NativeScript CLI will use the tools of the native SDKs to build these platform-specific projects into truly native application packages. During the process, the NativeScript CLI will automatically transfer your cross-platform code and resources from your project&#39;s <code>app</code> folder into its <code>platforms</code> folder.</p>
<p>Don&#39;t worry too much about the details, as the NativeScript CLI does a good job of abstracting you from the messy details. Let&#39;s look at how to run your app.</p>
<h3 id="running-your-app">Running your app</h3>
<p>With the platform initialization complete you can now run your app in an emulator or on devices. If you&#39;re on an app start by running the app in an iOS simulator with the following command:</p>
<pre><code>tns run ios --emulator
</code></pre><p>If all went well you should see something like this:</p>
<p><img src="images/login-logo-ios.png" alt="login"></p>
<p>Next run your app on Android with the following command:</p>
<pre><code>tns run android --emulator
</code></pre><p>If all went well you should see your app running in an Android emulator:</p>
<p><img src="images/login-logo-android.png" alt="login"></p>
<p>You&#39;ll find that running the app in an iOS emulator vs. an Android emulator offers a different user experience to the user. This is because NativeScript is actually leveraging native iOS and Android code to present the UI—cool, huh?</p>
<h3 id="making-changes-with-livesync">Making changes with LiveSync</h3>
<blockquote>
<p>Jen: I think we need to show people how to change a file and see that change happen live. LiveSync should provide a good workflow for this and it&#39;s coming in 1.2. So let&#39;s just hold off for now and reevaluate this post 1.2.</p>
<p>TODO: Reevaluate this after 1.2. At this point, you have the NativeScript CLI downloaded and installed, as well as the iOS and Android dependencies that you need to run your app on both the iOS and Android emulators. Now you need a good development workflow to ease development. <a href="http://developer.telerik.com/featured/a-nativescript-development-workflow-for-sublime-text/">This article</a> elaborates on a good workflow process that uses node, Sublime Text 3, and a Sublime Package to make building your NativeScript app for an emulator really fast and easy. We recommend that you configure your environment this way to save time.</p>
</blockquote>
<p>Now that you have your app created, your environment configured, and your app ready to emulate for iOS and Android, you&#39;re ready to start taking a look at the code structure.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="app-building-blocks">App building blocks</h2>
<p>Before you start coding the Groceries app it&#39;s important to understand a NativeScript app&#39;s folder structure. It&#39;ll help you understand where to place new files, as well as a bit of what&#39;s going with NativeScript on under the hood.</p>
<p>Go ahead and open the Groceries app&#39;s files up in your text editor of choice and let&#39;s dig in.</p>
<h3 id="directory-structure">Directory structure</h3>
<p>To keep things simple, let&#39;s start by looking at the outer structure of the Groceries app:</p>
<pre><code>.
└── Groceries
    ├── app
    │   └── ...
    ├── package.json
    └── platforms
        ├── android
        └── ios
</code></pre><ul>
<li><strong>app</strong>: The <code>app</code> folder contains all the development resources you need to build your app. Normally, you only touch code in the <code>app</code> folder during your development flow.</li>
<li><strong>package.json</strong>: This contains configuration about your app, such as you app id, the version of NativeScript you&#39;re using, and also which npm modules your app uses. We&#39;ll take a closer look at how to use this file in your app in chapter 5.</li>
<li><strong>platforms</strong>: This folders contains the platform-specific code NativeScript needs to build native iOS and Android apps. For instance in the <code>android</code> folder you&#39;ll find things like your project&#39;s <code>AndroidManifest.xml</code> and its .apk executable files. Similarly, in the <code>ios</code> folder, you&#39;ll find the Groceries&#39; Xcode project and the .ipa file NativeScript builds when deploying to an emulator or device.</li>
</ul>
<p>The NativeScript CLI manages the <code>platforms</code> for you as you develop and run your app; therefore it&#39;s a best practice to treat the <code>platforms</code> folder as generated code. The Groceries app includes <code>platforms/</code> in its <code>.gitignore</code> to exclude the files from source control.</p>
<p>Next, let&#39;s dig into the <code>app</code> folder, as that&#39;s where you&#39;ll be spending the majority of your time.</p>
<pre><code>.
└── Groceries
    ├── app
    │   ├── App_Resources
    │   │   ├── Android
    │   │   └── iOS
    │   ├── shared
    │   │   └── ...
    │   ├── tns_modules
    │   │   └── ...
    │   ├── views
    │   │   └── login
    │   │       ├── login.js
    │   │       └── login.xml
    │   ├── app.css
    │   ├── app.js
    │   └── ...
    └── ...
</code></pre><p>Let&#39;s look at what each of these files and folders do:</p>
<ul>
<li><strong>App_Resources</strong>: Contains platform-specific resources such as icons, splash screens, and configuration files. The NativeScript CLI takes care of injecting these resources into the appropriate places in the <code>platforms</code> folder when you execute <code>tns run</code>.</li>
<li><strong>shared</strong>: This folder contains any files you need to share across views in your app. In the Groceries app you find a few model objects and a <code>config.js</code> file used to share configuration variables like API keys.</li>
<li><strong>tns_modules</strong>: This folder contains the NativeScript-provided modules you&#39;ll use to build your app. Each module contains platform-specific code (camera, http, file system, etc), exposed through a platform-agnostic API (e.g. <code>http.getJSON()</code>). We&#39;ll look at some examples momentarily.</li>
<li><strong>views</strong>: Each of your app&#39;s views will have a subfolder in <code>views</code>. Each view is made up of an XML file, a JavaScript file, and an optional CSS file. For now on the login view is in this folder, but you&#39;ll be adding a few more later in this guide.</li>
<li><strong>app.css</strong>: Contains global styles for your app. We&#39;ll dig into app styling in section 2.4.</li>
<li><strong>app.js</strong>: Sets up your application&#39;s starting module and initializes the app.</li>
</ul>
<p>Take a look at <code>app/app.js</code>. This is the starting point for your app development, but it only contains three lines: </p>
<pre><code>var application = require(&quot;application&quot;);
application.mainModule = &quot;./views/login/login&quot;;
application.start();
</code></pre><p>Here, we&#39;re requiring, or importing, the tns module &#39;application&#39; which includes various other modules that are useful globally. Then, we set the main screen of our app to be the &#39;login&#39; screen which we&#39;ll look at below. And then we start up the app which loads the css as you can discover by looking in for the loadCss() function in app/tns_modules/application/application-common.js.</p>
<p>Now that our app is ready for development, let&#39;s turn our attention to its UI.</p>
<h3 id="ui-components">UI Components</h3>
<p>First let&#39;s take a look at the UI components. You&#39;ll find several folders in app/views. Each folder contains one page of your app: list, login, and register are there already. If you look at app/views/login, you&#39;ll see three files. We&#39;re going to turn our attention to app/views/login/login.xml. </p>
<p>In NativeScript&#39;s framework, you can construct a UI either using xml or JavaScript. Often, it&#39;s a bit easier to write your presentation layer in xml. Build out the login screen by adding some UI components, namely three boxes or &quot;Borders&quot;, two textfields, and a button.</p>
<p><strong>Exercise: Add UI components to login.xml</strong></p>
<p>Under the Image where the logo currently resides, add the following code:</p>
<pre><code>        &lt;Border borderWidth=&quot;1&quot; borderColor=&quot;#CECED2&quot;&gt;
            &lt;TextField id=&quot;email_address&quot; hint=&quot;Email Address&quot; /&gt;
        &lt;/Border&gt;
        &lt;Border borderWidth=&quot;1&quot; borderColor=&quot;#CECED2&quot;&gt;
            &lt;TextField secure=&quot;true&quot; hint=&quot;Password&quot; /&gt;
        &lt;/Border&gt;

        &lt;Border borderWidth=&quot;1&quot; borderColor=&quot;#0079FF&quot;&gt;
            &lt;Button text=&quot;Sign in&quot; tap=&quot;signIn&quot; /&gt;
        &lt;/Border&gt;

        &lt;Button text=&quot;Sign up for Groceries&quot; tap=&quot;register&quot; /&gt;
</code></pre><p>We&#39;ve added four items to our screen, three of which are surrounded with a Border component to make it look like a box. </p>
<ul>
<li>The TextField has the attributes you&#39;d expect such as ids, hints, and the parameter &#39;secure&#39; to ensure that a password isn&#39;t exposed. </li>
<li>The Button component has a tap function bound to it called &#39;signIn&#39; which will enable the user to login. </li>
<li>Another button looks more like a link but also has a function bound to it to enable registration. </li>
</ul>
<p>If you run your app at this point, you&#39;ll see the form:</p>
<p><img src="images/login-noregister.png" alt="login final"></p>
<p>Learn more about the UI components available in your app <a href="http://docs.nativescript.org/ui-with-xml">here</a>.</p>
<h3 id="layouts">Layouts</h3>
<p>You have many options in NativeScript when creating layouts. One of the simplest is demonstrated in login.xml, the StackLayout. Here, we see several UI components nested in StackLayout tags:</p>
<pre><code>&lt;StackLayout orientation=&quot;vertical&quot; horizontalAlignment=&quot;center&quot;&gt;
</code></pre><p>Each of those components will be stacked on top of each other, vertically. Learn more about creating NativeScript layouts <a href="http://docs.nativescript.org/layouts">here</a> and <a href="http://developer.telerik.com/featured/demystifying-nativescript-layouts/">here</a>.</p>
<p><strong>Exercise: Create a stacked layout for our registration screen.</strong></p>
<p>In /views/register/register.xml, add the following markup:</p>
<pre><code>&lt;Page loaded=&quot;load&quot;&gt;
    &lt;StackLayout&gt;
        &lt;Image src=&quot;res://logo&quot; stretch=&quot;none&quot; horizontalAlignment=&quot;center&quot;/&gt;

        &lt;Border borderWidth=&quot;1&quot; borderColor=&quot;#CECED2&quot;&gt;
            &lt;TextField text=&quot;{{ user.email_address }}&quot; id=&quot;email&quot; hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; /&gt;
        &lt;/Border&gt;

        &lt;Border borderWidth=&quot;1&quot; borderColor=&quot;#CECED2&quot;&gt;
            &lt;TextField text=&quot;{{ user.password }}&quot; secure=&quot;true&quot; hint=&quot;Password&quot; /&gt;
        &lt;/Border&gt;

        &lt;Border borderWidth=&quot;1&quot; borderColor=&quot;#0079FF&quot;&gt;
            &lt;Button text=&quot;Sign Up&quot; tap=&quot;register&quot; /&gt;
        &lt;/Border&gt;
    &lt;/StackLayout&gt;
&lt;/Page&gt;
</code></pre><ul>
<li>Notice the function that is invoked when the Page is loaded: we&#39;ll take a look at the &#39;load&#39; function in the code-behind file that we&#39;ll construct next. </li>
<li>Notice also the way we load an image, with its source as &quot;res://logo&quot; and its stretch attribute set to &#39;none&#39;. We&#39;ll talk more about handling images below as well. </li>
<li>Finally, note the TextField&#39;s two-way binding, set up to bind its text to &quot;user.email_address&quot; or &quot;user.password&quot;. We&#39;ll also discuss data-binding below.</li>
</ul>
<h3 id="code-behind-files">Code-behind files</h3>
<p>Although you can now see your login and registration screens, they are not yet wired up to send data to the backend. Let&#39;s fix that.</p>
<p>In app/views/login, you&#39;ll find login.js. This is called a &#39;code-behind&#39; file because it supports the xml markup that constructs the presentation tier. </p>
<p><strong>Exercise: Construct the login code-behind file.</strong></p>
<p>Add some required elements at the top of this file:</p>
<pre><code>var view = require(&quot;ui/core/view&quot;);
var dialogs = require(&quot;ui/dialogs&quot;);
var frameModule = require(&quot;ui/frame&quot;);

var page;

var User = require(&quot;../../shared/models/User&quot;);
var user;
</code></pre><p>In login.xml, notice a &#39;load&#39; function that, when the page is loaded, initializes several variables. Let&#39;s build up that load function in app/views/login/login.js:</p>
<pre><code>exports.load = function(args) {

    user = new User();

    var page = args.object;
    page.bindingContext = user;

};
</code></pre><p>As we saw earlier, in login.xml, a button is bound to the signIn function:</p>
<pre><code>&lt;Button text=&quot;Sign in&quot; tap=&quot;signIn&quot; /&gt;
</code></pre><p>Construct the signIn function in app/views/login/login.js. :</p>
<pre><code>exports.signIn = function() {
    user.login()
        .then(function() {
            frameModule.topmost().navigate(&quot;./views/list/list&quot;);
        }).catch(function() {
            dialogs.alert({
                message: &quot;Unfortunately we could not find your account.&quot;,
                okButtonText: &quot;OK&quot;
            });
        });
};
</code></pre><p>NativeScript supports JavaScript modules and their implementation follows the <a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS specification</a>. Using the &#39;<a href="http://wiki.commonjs.org/wiki/Modules/1.1#Module_Context">require</a>&#39; function at the top of this file allows us to identify a module to be imported, and it returns the exported API of this module.</p>
<p>Similarly, we see the variable &#39;exports&#39;, which is an object that the module may add its API to as it executes.</p>
<p>In this file, we export the functions &#39;load&#39; and &#39;signIn&#39;. These functions set up the login routine to pass data through to the Model. We&#39;ll visit the Model below.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="nativescript-modules">NativeScript modules</h2>
<p>In the previous chapter, we already saw how NativeScript leverages the concept of &#39;modules&#39; to include bits of code that are kept in the tns_modules folder. Using &#39;require&#39;, you can include these snippets ad hoc in your code when you need to use them, similar to the way we use npm to import node libraries. Let&#39;s take a closer look at these modules and what they can do for us.</p>
<h3 id="navigation-and-the-frame-module">Navigation and the frame module</h3>
<p>While our Groceries app doesn&#39;t use complex navigation strategies, you have several available to you out of the box:</p>
<p><a href="http://docs.nativescript.org/ui-views#tabview">TabView</a><br><a href="http://docs.nativescript.org/ui-views#segmentedbar">SegmentedBar</a></p>
<p><strong>Exercise: Enable the &quot;Sign Up&quot; button on the login screen with a navigational change</strong></p>
<p>Right now, if you were to click the Sign Up For Groceries button on the login screen, nothing would happen. Let&#39;s get this button to change the screen to show a registration form. </p>
<p>In app/views/login/login.js, add the following function under the signIn function:</p>
<pre><code>exports.register = function() {
    var topmost = frameModule.topmost();
    topmost.navigate(&quot;./views/register/register&quot;);
};
</code></pre><p>This function makes use of the module &#39;frameModule&#39; which looks for the topmost frame and navigates to it. Here, we tell the topmost frame to navigate to the register view. If you run your code in an emulator, you&#39;ll find that you can now navigate to your registration view by clicking the &quot;Sign Up&quot; button.</p>
<p>Learn more about how to link up your navigational strategies <a href="http://docs.nativescript.org/navigation#navigation">here</a>.</p>
<h3 id="connecting-to-a-backend-with-the-http-module">Connecting to a backend with the http module</h3>
<p>You probably noticed that while we were busy constructing the frontend xml and the code-behind JavaScript file, data was passing magically...somewhere. There&#39;s actually no magic involved; we have a config file that contains our API Key to <a href="http://www.telerik.com/backend-services">Telerik Backend Services</a>, a place where we are storing our users&#39; information.</p>
<p>Take a look at app/shared/config.js. There&#39;s only a small code snippet there, but it includes a hard-coded API Key that we use throughout the app to access the backend (in real life, you would of course use your own API Key):</p>
<pre><code>module.exports = {
    apiUrl: &quot;http://api.everlive.com/v1/GWfRtXi1Lwt4jcqK/&quot;
};
</code></pre><p>The config file is used in our Model files, in particular our User Model: app/shared/models/User.js:</p>
<pre><code>var config = require(&quot;../../shared/config&quot;);
</code></pre><p>It is used to construct a url via which we can send stringified JSON data via POST:</p>
<pre><code>http.request({
    url: config.apiUrl + &quot;oauth/token&quot;,
    method: &quot;POST&quot;,
    content: JSON.stringify({
        username: that.get(&quot;email_address&quot;),
        password: that.get(&quot;password&quot;),
        grant_type: &quot;password&quot;
    }),
    headers: {
        &quot;Content-Type&quot;: &quot;application/json&quot;
    }
</code></pre><p>In the sample above, we use the &#39;http&#39; module which we simply &#39;require&#39; at the top of the User.js file:</p>
<pre><code>var http = require(&quot;http&quot;);
</code></pre><p>If you dig a bit into the tns_modules folder and find the http folder, you can see how a tns module is constructed. It includes:</p>
<ul>
<li>a package.json that sets the name of the module and includes the base http.js file</li>
<li>a file containing android native code (http-request.android.js) </li>
<li>a file containing ios native code (http-request.ios.js)</li>
<li>a generic file (http.js) that abstract the platform-specific code above into a platform-agnostic format readable by the NativeScript runtime.</li>
</ul>
<p>More information on modules can be found <a href="http://developer.telerik.com/featured/nativescript-works/">here</a>.</p>
<h3 id="dialog-module">Dialog module</h3>
<p>The dialog module is also used several times in our Groceries app. Its code is found in the tns_modules/ui folder with other UI widgets. To use this module, you have several options, including control over the buttons you include in the alert and their text, along with custom messaging in the alert itself:</p>
<pre><code>dialogs.alert({
    message: &quot;Unfortunately we were unable to create your account.&quot;,
    okButtonText: &quot;OK&quot;
});
</code></pre><h3 id="listview">ListView</h3>
<p>Let&#39;s use another UI module to craft a page to actually hold our grocery data. This is the page we want users to navigate to once they login, so let&#39;s add a line in app/views/login/login.js to allow this navigation to happen. In the signIn function, add the following line after &#39;.then(function(){&#39;:</p>
<pre><code>frameModule.topmost().navigate(&quot;./views/list/list&quot;);
</code></pre><p><strong>Exercise: Construct the list view</strong></p>
<p>In app/views/list/list.xml, let&#39;s get started using the ListView module by creating a list where our groceries will reside:</p>
<pre><code>&lt;Page navigatedTo=&quot;navigatedTo&quot;&gt;
    &lt;GridLayout rows=&quot;auto, *&quot; columns=&quot;*, *, *&quot;&gt;
        &lt;Border borderWidth=&quot;10&quot; borderColor=&quot;#034793&quot; row=&quot;0&quot; colSpan=&quot;2&quot;&gt;
            &lt;TextField id=&quot;grocery&quot; text=&quot;{{ grocery }}&quot; hint=&quot;Enter a grocery item&quot;/&gt;
        &lt;/Border&gt;

        &lt;Button text=&quot;Add&quot; tap=&quot;add&quot; row=&quot;0&quot; col=&quot;2&quot;&gt;&lt;/Button&gt;

        &lt;ListView items=&quot;{{ groceryList }}&quot; row=&quot;1&quot; colSpan=&quot;3&quot;&gt;
            &lt;ListView.itemTemplate&gt;
                &lt;Label text=&quot;{{ name }}&quot; horizontalAlignment=&quot;left&quot;/&gt;
            &lt;/ListView.itemTemplate&gt;
        &lt;/ListView&gt;
    &lt;/GridLayout&gt;
&lt;/Page&gt;
</code></pre><p>Note our use of the ListView module. In this case, we&#39;re not requiring a tns_module from the ui folder, but are rather using the ui widget within the xml code. This is a different way of using these modules. If we wanted to, we could construct a ListView in pure JavaScript code behind the scenes as shown in <a href="http://docs.nativescript.org/ApiReference/ui/list-view/HOW-TO.html">this example</a>. However for our purposes, we can simply use xml to build the ListView and thereby follow the pattern we use in the login and register screens.</p>
<p>Let&#39;s go ahead and build the code-behind file as usual. In app/views/list/list.js, add:</p>
<pre><code>var view = require(&quot;ui/core/view&quot;);
var viewModel = require(&quot;./list-view-model&quot;);
var page;

exports.navigatedTo = function(args) {
    page = args.object;
    if (page.ios) {
        page.ios.title = &quot;Groceries&quot;;
    }

    page.bindingContext = viewModel;
    viewModel.reset();
};
</code></pre><p>There are a couple of things happening in this file. First, we have the function navigatedTo, which will set up our page for data binding when we navigate to it in the xml:</p>
<pre><code>&lt;Page navigatedTo=&quot;navigatedTo&quot;&gt;
</code></pre><p>Notice the use of a slightly different pattern in the code-behind file. In this case, we&#39;re going to use a View Model file separately from the code-behind file. We&#39;ll get into more detail in the next chapter.</p>
<h3 id="css">CSS</h3>
<p>NativeScript considers CSS a type of tns_module, and you can dig into the code in app/tns_modules/ui/styling. The framework supports a subset of CSS so that you can add styles to your app. We include global styles in app/app.css, where you&#39;ll find some styles that format all the textfields, buttons and borders. You can also include individual css files in each view folder, which would be appropriate for styles that are isolated to a certain page.  </p>
<p>We don&#39;t have to worry about any particular CSS styling in the login or register screens, but let&#39;s turn our attention to the grocery list itself which appears after logging in. It needs a little massaging, so let&#39;s add a few CSS styles to app/views/list/list.css:</p>
<pre><code>ListView {
    margin: 10;
}
Label {
    margin: 10;
}
Border {
    margin: 0;
}
</code></pre><p>This will give us a lttle more room for our groceries to display nicely.</p>
<p><img src="images/list-view-2.png"/></p>
<h3 id="other-modules">Other modules</h3>
<p>There are several modules that come out of the box with your NativeScript install, including a location service, a file-system helper, timer, camera, and even a color module that helps navigate the ways various colors are handled cross-platform. If you are interested in helping build and distribute more modules for the community, there&#39;s a <a href="http://developer.telerik.com/featured/building-your-own-nativescript-modules-for-npm/">good guide</a> available on how to do this.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="mvvm">MVVM</h2>
<h3 id="what-is-mvvm-">What is MVVM?</h3>
<p>In this chapter, we&#39;ll learn about the base pattern on which the NativeScript framework is built, MVVM, or &quot;Model, View, View Model&quot;. MVVM is an architectural pattern that helps you separate the UI from the application logic and data model. We&#39;ve already seen several examples of the elements that are used in this design pattern:</p>
<ul>
<li>Model: The model defines and represents the data. Separating the model from the various views that may use it allows for code reuse.</li>
<li>View: The view represents the UI. The view is often data-bound to the View Model so that changes are instantly represented on the presentation tier.</li>
<li>View Model: The View Model contains the application logic, expositing it for the View.</li>
</ul>
<p>The most basic benefit of using this sort of separation between the Model, View, and View Model, is that we are able to craft two-way data binding such that the View Model can act as a switchboard between the Model and the View. Let&#39;s wire up our login xml to support binding.</p>
<h3 id="data-binding">Data Binding</h3>
<p><strong>Exercise: Bind data to the frontend of login.xml</strong></p>
<p>Instead of just showing a blank text field, we can help the user login more quickly by binding data to the login text fields. In app/views/login/login.xml, edit the username text field to show a default username:</p>
<pre><code>&lt;TextField text=&quot;{{ email_address }}&quot; id=&quot;email_address&quot; hint=&quot;Email Address&quot; /&gt;
</code></pre><p>Similarly, edit the password field in this file:</p>
<pre><code>&lt;TextField secure=&quot;true&quot; text=&quot;{{ password }}&quot; hint=&quot;Password&quot; /&gt;
</code></pre><p>This way, you can pull in values from the code-behind file into your app; add the following two lines at the bottom of the load function in app/views/login/login.js:</p>
<pre><code>user.set(&quot;email_address&quot;, &quot;tj.vantoll@gmail.com&quot;);
user.set(&quot;password&quot;, &quot;password&quot;);
</code></pre><p>If you run the app, you&#39;ll find that the email address and password fields are pre-populated with data coming via the View Model.</p>
<p>You can create your MVVM code structure like we did for login, with only login.xml and login.js communicating with User.js as its model. Alternately, you can include a second file specific to the View Model for each page. We&#39;re going to do this latter pattern for our Registration field.</p>
<h3 id="constructing-a-view-model">Constructing a View Model</h3>
<p>While you can certainly keep your View Model functionality in the code-behind file as we did for the login routines, an alternate pattern involves separating the code-behind file from a view-model.js file. This separation helps you isolate concerns for more effective unit testing. Let&#39;s build out the registration form using this pattern.</p>
<blockquote>
<p>A best practice for working within the MVVM pattern is to build the View Model first, before even touching the UI. The View Model shouldn&#39;t be aware of UI elements at all, it simply channels data back and forth.</p>
</blockquote>
<p><strong>Exercise: Construct the Registration View Model</strong></p>
<p>Let&#39;s get the View Model into place so that data from the frontend XML can filter through the code-behind file, through the View Model, and over to the Model. We need to start with requiring and creating an Observable object.</p>
<blockquote>
<p><strong>Observable</strong> is a core building block for a View Model. It provides it with a mechanism required for two-way data binding so as to provide communication between the View and the View Model. This means that if the user updates the data in the UI the change will be reflected in the ViewModel and vice versa.</p>
</blockquote>
<p>In app/views/register/register-view-model.js, add the following code:</p>
<pre><code>var dialogs = require(&quot;ui/dialogs&quot;);
var frameModule = require(&quot;ui/frame&quot;);
var observable = require(&quot;data/observable&quot;);
var User = require(&quot;../../shared/models/User&quot;);
</code></pre><p>Here, we&#39;re including several NativeScript modules, including dialog, frameModule, and observable. We also include the User Model so that it is available for data pass-through.</p>
<p>Under that code, create a function that creates a new user based on the User Model:</p>
<pre><code>function RegisterViewModel() {
    this.set(&quot;user&quot;, new User());
}
</code></pre><p>Then, we can use the prototype pattern to create a new bindable object, the RegisterViewModel:</p>
<pre><code>RegisterViewModel.prototype = new observable.Observable();
</code></pre><p>Next, add in the register function to handle the way the UI will be have based on the response of the model to data passed to it:</p>
<pre><code>RegisterViewModel.prototype.register = function() {
    this.get(&quot;user&quot;).register()
        .then(function() {
            dialogs
                .alert(&quot;Your account was successfully created.&quot;)
                .then(function() {
                    frameModule.topmost().navigate(&quot;./views/login/login&quot;);
                });
        }).catch(function() {
            dialogs.alert({
                message: &quot;Unfortunately we were unable to create your account.&quot;,
                okButtonText: &quot;OK&quot;
            });
        });
};
</code></pre><p>And finally, export this new View Model which we have called RegisterViewModel:</p>
<pre><code>module.exports = new RegisterViewModel();
</code></pre><p>Note that, similarly to the way data is handled in login, we have set up a new prototype for registration, and invoked the function that is handled in app/shared/models/Users.js. The user is either registered or there is a problem, in which case a dialog pops up. We use the dialog ui by including it at the top of the View Model file, as you saw above.</p>
<p>Now that we have the View Model finished, we can build the view and bind it to the View Model. We created the xml for the view earlier so as to learn about layouts, so let&#39;s create the registration code-behind file.</p>
<p><strong>Exercise: Build the registration code-behind file</strong></p>
<p>Since we have moved much of the application logic to the registration-view-model.js file, we can use the code-behind file to contain logic closer to the UI. In this case, we&#39;re going to add some OS-specific code to handle autocorrecting behavior. In app/register/register.js, include the core module &#39;view&#39; so that we can control the view from this file, and include the View Model:</p>
<pre><code>var view = require(&quot;ui/core/view&quot;);
var viewModel = require(&quot;./register-view-model&quot;);
</code></pre><p>Next, add the load function that is invoked from the xml:</p>
<pre><code>exports.load = function(args) {
    var page = args.object;
    var email = view.getViewById(page, &quot;email&quot;);

    page.bindingContext = viewModel;

    // Turn off autocorrect and autocapitalization for iOS
    if (email.ios) {
        email.ios.autocapitalizationType =
            UITextAutocapitalizationType.UITextAutocapitalizationTypeNone;
        email.ios.autocorrectionType =
            UITextAutocorrectionType.UITextAutocorrectionTypeNo;
        email.ios.keyboardType =
            UIKeyboardType.UIKeyboardTypeEmailAddress;
    }
};
</code></pre><p>In this snippet, we use a bit of native code to manage the keyboard and stop capitalization in the email field, based on its id.</p>
<p>Then, route the logic for the registration routine through this file to the View Model:</p>
<pre><code>exports.register = function() {
    viewModel.register();
};
</code></pre><p>Now we are ready for our presentation layer to pass information through the View Model and over to the Model.</p>
<p><strong>Exercise: Wire up the registration function in the Model</strong></p>
<p>Let&#39;s get something to happen when we click the register button in the register screen. Add the following code to /app/shared/models/User.js:</p>
<pre><code>User.prototype.register = function() {
    var that = this;
    return new Promise(function(resolve, reject) {
        http.request({
            url: config.apiUrl + &quot;Users&quot;,
            method: &quot;POST&quot;,
            content: JSON.stringify({
                Username: that.get(&quot;email_address&quot;),
                Email: that.get(&quot;email_address&quot;),
                Password: that.get(&quot;password&quot;)
            }),
            headers: {
                &quot;Content-Type&quot;: &quot;application/json&quot;
            }
        }).then(function() {
            resolve();
        }).catch(function() {
            reject();
        });
    });
};
</code></pre><p>Now, if you rebuild and run your app in an emulator, you can register a new user! </p>
<p><img src="images/registration-success.png"/></p>
<p>Now that we have both login and registration routines complete, we need to work on the app&#39;s actual functionality as a grocery list management tool.</p>
<h3 id="connecting-a-model-and-a-view-model">Connecting a Model and a View Model</h3>
<p>To be able to manage data in the grocery list, we need to build a connection between the presentation tier and the database as we did for registration. Let&#39;s build out these pieces in our grocery list.</p>
<p><strong>Exercise: Construct the list Model and View Model</strong></p>
<p>In app/views/list/list-view-model.js, add:</p>
<pre><code>var dialogs = require(&quot;ui/dialogs&quot;);
var observable = require(&quot;data/observable&quot;);
var GroceryList = require(&quot;../../shared/models/GroceryList&quot;);

function ListViewModel() {
    this.set(&quot;grocery&quot;, &quot;&quot;);
    this.set(&quot;groceryList&quot;, new GroceryList([]));
}
ListViewModel.prototype = new observable.Observable();

ListViewModel.prototype.reset = function() {
    this.get(&quot;groceryList&quot;).empty();
    this.get(&quot;groceryList&quot;).load();
};

module.exports = new ListViewModel();
</code></pre><p>Here, we&#39;re creating a new empty grocery array and a groceryList variable to instantiate our GroceryList object that we create in the Model. We&#39;re also emptying and refilling our groceryList in the reset function. Let&#39;s create the GroceryList object in the Model:</p>
<p>In app/shared/models/GroceryList.js, let&#39;s grab any Grocery data that might exist in the backend and push it into the grocery array:</p>
<pre><code>var config = require(&quot;../../shared/config&quot;);
var http = require(&quot;http&quot;);
var observableArray = require(&quot;data/observable-array&quot;);

function GroceryList() {}
GroceryList.prototype = new observableArray.ObservableArray([]);

GroceryList.prototype.load = function() {
    var that = this;
    http.getJSON({
        url: config.apiUrl + &quot;Groceries&quot;,
        method: &quot;GET&quot;,
        headers: {
            &quot;Authorization&quot;: &quot;Bearer &quot; + config.token
        }
    }).then(function(data) {
        data.Result.forEach(function(grocery) {
            that.push({ name: grocery.Name });
        });
    });
};

GroceryList.prototype.empty = function() {
    while (this.length) {
        this.pop();
    }
};

module.exports = GroceryList;
</code></pre><p>In the load function above, we are pulling down the list associated to the user&#39;s credentials. If you rebuild, run the app, and login as tj.vantoll@gmail.com, you&#39;ll find a list of groceries pulled from Backend services in the Groceries data type. It will look something like this:</p>
<p><img src="images/list-view-1.png"/></p>
<p>It&#39;s great that we can see data already in the database, but we also need to add some items. Let&#39;s build that functionality.</p>
<p><strong>Exercise: Add the ability to create a Grocery item</strong></p>
<p>Notice at the top of the list is a text area and an &#39;Add&#39; button. Right now, it doesn&#39;t do anything. Let&#39;s fix that.</p>
<p>In app/views/list/list.js, add a function to respond to the &#39;add&#39; tap event that is already in list.xml. We&#39;ll put this underneath the navigatedTo function.</p>
<pre><code>exports.add = function() {
    view.getViewById(page, &quot;grocery&quot;).dismissSoftInput();
    viewModel.add();
};
</code></pre><p>Notice that this function performs two tasks: first, it dismisses the keyboard, and then it calls the add function in the ViewModel. </p>
<p>In app/views/list/list-view-model.js, let&#39;s add that &#39;add&#39; function to pass data to the model:</p>
<pre><code>ListViewModel.prototype.add = function() {
    this.get(&quot;groceryList&quot;).add(this.get(&quot;grocery&quot;))
        .catch(function() {
            dialogs.alert({
                message: &quot;An error occurred adding to your list.&quot;,
                okButtonText: &quot;OK&quot;
            });
        });
    this.set(&quot;grocery&quot;, &quot;&quot;);
};
</code></pre><p>In this function, we get the &#39;grocery&#39; item from the input field and add it to the groceryList object. </p>
<p>Finally, let the manipulation of this new data be handled in the Model by adding the following function under the &#39;empty&#39; function in /app/shared/models/GroceryList.js:</p>
<pre><code>GroceryList.prototype.add = function(grocery) {
    var that = this;
    return new Promise(function(resolve, reject) {
        http.request({
            url: config.apiUrl + &quot;Groceries&quot;,
            method: &quot;POST&quot;,
            content: JSON.stringify({
                Name: grocery
            }),
            headers: {
                &quot;Authorization&quot;: &quot;Bearer &quot; + config.token,
                &quot;Content-Type&quot;: &quot;application/json&quot;
            }
        }).then(function() {
            that.push({ name: grocery });
            resolve();
        }).catch(function() {
            reject();
        });
    });
};
</code></pre><p>If you build and rerun your app now, you&#39;ll find that you can add a grocery item and it will appear immediately in your list.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="using-npm">Using npm</h2>
<p>Often, we need to include modules that are not by default available in tns_modules to allow for special functionality. We can leverage npm, node package manager, to import plugins and modules into our project. Let&#39;s add the <a href="https://www.npmjs.com/package/nativescript-social-share">NativeScript Social Share widget</a> so that we can email our grocery lists.</p>
<h3 id="using-npm-modules-in-your-app">Using npm modules in your app</h3>
<p><strong>Exercise: Install and use the Social Sharing widget</strong></p>
<p>Cd to the app directory in your Groceries project folder:</p>
<pre><code>cd Documents/NativeScript/Groceries/app/
</code></pre><p>and install the module:</p>
<pre><code>npm install nativescript-social-share
</code></pre><p>We&#39;re going to add this functionality to our list of groceries, so in /app/views/list/list.js, require the module:</p>
<pre><code>var socialShare = require(&quot;../../node_modules/nativescript-social-share/social-share&quot;);
</code></pre><p>Let&#39;s make an area at the top of our list file to show a link to share a grocery list. Under the <Page> tag, add the following code. Tapping this link will open a native email sharing widget:</p>
<pre><code>&lt;Page.optionsMenu&gt;
    &lt;MenuItem text=&quot;Share&quot; tap=&quot;share&quot; android.position=&quot;actionBar&quot;/&gt;
&lt;/Page.optionsMenu&gt;
</code></pre><p>Now we need to get our grocery list into a comma-delimited format that will be fed to the socialSharing widget. To do this, add a function to return our list at the bottom of list-view-model.js:</p>
<pre><code>ListViewModel.prototype.getList = function(){
    var groceryList = this.get(&quot;groceryList&quot;);
    var list = {};
    for(var i = 0, size = groceryList.length; i &lt; size ; i++){
       list[i] = groceryList.getItem(i).name;
       console.log(list[i])
    }
    return list
}
</code></pre><p>And then finally add a function in app/views/list/list.js to call the socialSharing widget:</p>
<pre><code>exports.share = function() {
    var list = viewModel.getList();
    socialShare.shareText(list);
}
</code></pre><p>Now when you run the app, you&#39;ll see a Share button at the top that, when clicked, allows you to email a list using a native interface:</p>
<p><img src="images/share-view.png" alt="share">
<img src="images/share-email.png" alt="share"></p>
<p>It&#39;s very cool to add ready-built modules to your app. But maybe you want to build your own! </p>
<h3 id="building-your-own-nativescript-modules">Building your own NativeScript modules</h3>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="accessing-native-apis">Accessing native APIs</h2>
<p>...</p>
<h3 id="how-it-works">How it works</h3>
<p>...</p>
<h3 id="deleting-from-a-list">Deleting from a list</h3>
<p>...</p>
<h3 id="using-android-and-ios-files">Using android and ios files</h3>
<p>...</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="next-steps">Next steps</h2>
<p>...</p>
<h3 id="documentation">Documentation</h3>
<p>...</p>
<h3 id="showcase">Showcase</h3>
<p>...</p>

		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>