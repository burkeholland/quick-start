<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>NativeScript Quick Start</title>

	<meta charset="utf-8">
	<meta name="description" content="A quick-start guide for NativeScript CLI apps">
	<meta name="author" content="TJ VanToll, Jen Looper">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="header">
	<a href="#" class="menu header-btn" id="toggle-toc"></a>
	<h1>NativeScript Quick Start</h1>
	<a href="https://github.com/NativeScript/quick-start" class="github header-btn"></a>
</div>

<div id="container">
	<div id="toc">
		<div class="author">By <a href="http://tjvantoll.com">@tjvantoll</a>, <a href="http://www.ladeezfirstmedia.com">@jenlooper</a></div>
		<div id="toc-padding"></div>
	</div>
	<div id="book">
		<div class="chapter">
			<h2 id="introduction">Introduction</h2>
<p style="color: red;">
    <b>Warning:</b> The guide you see here is a work in progress. You are welcome to go through the guide, but please keep in mind the guide is not complete; it has not been proofread; and there are certainly errors. If you have any high-level feedback on the guide feel free to document it on <a href="https://github.com/NativeScript/quick-start/issues">our issue tracker</a>.
</p>

<p>Welcome to the <a href="https://nativescript.org">NativeScript</a> Getting Started Guide. Using this guide, you&#39;ll use NativeScript, a cross-platform JavaScript framework for building native mobile apps, to build an iOS and Android app from scratch.</p>
<p><img src="images/nativescript-logo.jpg" alt="NativeScript.org logo"></p>
<h3 id="what-you-re-building">What you&#39;re building</h3>
<p>Here&#39;s the premise: your boss has tasked you with creating the next great grocery management app. You&#39;re given some designs from your design team, a few HTTP endpoints from your back end team, and you&#39;re told to build an app that does the following things:</p>
<ul>
<li>Allows users to register and login.</li>
<li>Allows authenticated users to add and delete groceries from a list.</li>
<li>Connects to your companies&#39; existing RESTful services.</li>
<li>Meets your design team&#39;s “native” mockups.</li>
<li>Runs cross-platform—i.e. iOS and Android.</li>
<li>Runs cross-device—i.e. phones and tablets.</li>
</ul>
<p>This guide will walk you through building an app that meets these requirements and more. If you follow along to the end here&#39;s what the finished app looks like on iOS:</p>
<p><img src="images/login-screenshot.png" alt="login">
<img src="images/register-screenshot.png" alt="register">
<img src="images/list-screenshot.png" alt="list"></p>
<p>And here&#39;s what the app looks like on Android:</p>
<p><img src="images/screenshot-placeholder.png" alt="placeholder">
<img src="images/screenshot-placeholder.png" alt="placeholder">
<img src="images/screenshot-placeholder.png" alt="placeholder"></p>
<p>By building “Groceries“ you&#39;ll see just how easy and fun it is to build iOS and Android apps with NativeScript. Let&#39;s get started.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="getting-up-and-running">Getting up and running</h2>
<p>There are two ways to use NativeScript: through the NativeScript Command-Line Interface (CLI) and through <a href="http://www.telerik.com/appbuilder">Telerik AppBuilder</a>. Although the NativeScript framework itself is the same regardless of whether you use the CLI or AppBuilder, the way you interface with NativeScript—how you run your app, how you change configuration files, and so forth—differs based on the interface you choose.</p>
<p>For this guide, we&#39;re assuming that you are going to develop your app on your local computer using the NativeScript CLI. Although most of the steps and advice given in this guide apply equally to using NativeScript through the CLI or AppBuilder, some—mostly related to development workflow—are specific to using NativeScript through the NativeScript CLI.</p>
<h3 id="install-nativescript-and-configure-your-environment">Install NativeScript and configure your environment</h3>
<p>The NativeScript CLI has a few system requirements you must have in place before building NativeScript apps. As a first step start by going through the appropriate instructions below depending on your development machine&#39;s operating system:</p>
<ul>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-win.html">Windows</a></li>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-os-x.html">OS X</a></li>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-linux.html">Linux</a></li>
</ul>
<p>Once you have the setup complete, use the <code>npm install</code> command to install the NativeScript CLI itself:</p>
<pre><code>$ npm install -g nativescript
</code></pre><p>You should now have two commands available from your terminal: <code>tns</code>—which is short for <strong>T</strong>elerik <strong>N</strong>ative<strong>S</strong>cript—and <code>nativescript</code>. The two commands are equivalent, so we&#39;ll stick with the shorter <code>tns</code> command throughout this guide.</p>
<p>You can verify the installation was successful by running <code>tns</code> in your terminal. You should see something like this:</p>
<pre><code>$ tns
# NativeScript
┌─────────┬─────────────────────────────────────────────────────────────────────┐
│ Usage   │ Synopsis                                                            │
│ General │ $ tns &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;]          │
│ Alias   │ $ nativescript &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;] │
└─────────┴─────────────────────────────────────────────────────────────────────┘
</code></pre><h3 id="start-your-app">Start your app</h3>
<p>With NativeScript CLI installed, it&#39;s time to start your app. You normally use the <code>tns create</code> command to create new apps—e.g. <code>tns create hello-world</code>—but for this guide we&#39;ve scaffolded out a boilerplate project to act as a starting point for <a href="https://github.com/NativeScript/sample-Groceries">Groceries</a>. To get it, navigate to a folder where you want to keep your app&#39;s code and clone the Groceries repo:</p>
<pre><code>$ cd folder-you-want-groceries-to-be-in
$ git clone https://github.com/NativeScript/sample-Groceries.git
$ cd groceries
</code></pre><p>The master branch has the final state of the Groceries app. Feel free to refer back to it at any time, but for now switch over to the “start” branch for the guide&#39;s starting point:</p>
<pre><code>$ git checkout start
</code></pre><h3 id="add-target-development-platforms">Add target development platforms</h3>
<p>Your project is now setup, but before you run it you have to do a little iOS- and Android-specific configuration using the <code>tns platform add</code> command. Start by adding the Android platform:</p>
<pre><code>$ tns platform add android
</code></pre><p>And if you&#39;re on a Mac add the iOS platform next:</p>
<pre><code>$ tns platform add ios
</code></pre><p>The <code>platform add</code> command uses the native SDKs to initialize platform-specific projects and places the generated contents in your app&#39;s <code>platforms</code> folder. Later on, the NativeScript CLI will use the tools of the native SDKs to build these platform-specific projects into truly native application packages. During the process, the NativeScript CLI will automatically transfer your cross-platform code and resources from your project&#39;s <code>app</code> folder into its <code>platforms</code> folder.</p>
<p>Don&#39;t worry too much about the details, as the NativeScript CLI does a good job of abstracting you from the messy details. Let&#39;s look at how to run your app.</p>
<h3 id="running-your-app">Running your app</h3>
<p>With the platform initialization complete you can now run your app in an emulator or on devices. If you&#39;re on an app start by running the app in an iOS simulator with the following command:</p>
<pre><code>tns run ios --emulator
</code></pre><p>If all went well you should see something like this:</p>
<p><img src="images/login-intro1-ios.png" alt="login"></p>
<p>Next run your app on Android with the following command:</p>
<pre><code>tns run android --emulator
</code></pre><p>If all went well you should see your app running in an Android emulator:</p>
<p><img src="images/login-intro1-android.png" alt="login"></p>
<p>You&#39;ll find that running the app in an iOS emulator vs. an Android emulator offers a different user experience to the user. This is because NativeScript is actually leveraging native iOS and Android code to present the UI—cool, huh?</p>
<h3 id="development-workflow">Development workflow</h3>
<p>At this point, you have the NativeScript CLI downloaded and installed, as well as the iOS and Android dependencies that you need to run your app on both the iOS and Android emulators. Now you need a good workflow that lets you make changes and see results fast.</p>
<blockquote>
<p><strong>TODO</strong>: Discuss <a href="https://github.com/NativeScript/nativescript-cli/issues/523">LiveSync</a>, which is coming in version 1.2. Walk the reader through making a change and see it happen on iOS/Android. A gif would be good here.</p>
<p><strong>A note about console.log</strong>: As you run your app, you can watch the terminal window and see a lot of useful debugging code. Scroll up to find errors as they occur, and to view logging messages that you can include by adding <code>console.log(&quot;a test message&quot;)</code> anywhere where you want to check for bugs.</p>
</blockquote>
<p>Now that you have your app created, your environment configured, and your app ready to emulate for iOS and Android, you&#39;re ready to start taking a look at the code structure.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="building-the-ui">Building the UI</h2>
<p>Before you start coding the Groceries app it&#39;s important to understand a NativeScript app&#39;s folder structure. It&#39;ll help you understand where to place new files, as well as a bit of what&#39;s going with NativeScript on under the hood.</p>
<p>Go ahead and open the Groceries app&#39;s files up in your text editor of choice and let&#39;s dig in.</p>
<h3 id="directory-structure">Directory structure</h3>
<p>To keep things simple, let&#39;s start by looking at the outer structure of the Groceries app:</p>
<pre><code>.
└── Groceries
    ├── app
    │   └── ...
    ├── package.json
    └── platforms
        ├── android
        └── ios
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>app</strong>: This folder contains all the development resources you need to build your app.</li>
<li><strong>package.json</strong>: This file contains configuration about your app, such as your app id, the version of NativeScript you&#39;re using, and also which npm modules your app uses. We&#39;ll take a closer look at how to use this file when we talk about using npm modules in chapter 5.</li>
<li><strong>platforms</strong>: This folder contains the platform-specific code NativeScript needs to build native iOS and Android apps. For instance in the <code>android</code> folder you&#39;ll find things like your project&#39;s <code>AndroidManifest.xml</code> and .apk executable files. Similarly the <code>ios</code> folder contains the Groceries&#39; Xcode project and the .ipa executables.</li>
</ul>
<p>The NativeScript CLI manages the <code>platforms</code> folder for you as you develop and run your app; therefore it&#39;s a best practice to treat the <code>platforms</code> folder as generated code. The Groceries app includes the <code>platforms</code> folder in its <code>.gitignore</code> to exclude its files from source control.</p>
<p>Next, let&#39;s dig into the <code>app</code> folder, as that&#39;s where you&#39;ll be spending the majority of your time.</p>
<pre><code>.
└── Groceries
    ├── app
    │   ├── App_Resources
    │   │   ├── Android
    │   │   └── iOS
    │   ├── shared
    │   │   └── ...
    │   ├── tns_modules
    │   │   └── ...
    │   ├── views
    │   │   └── login
    │   │       ├── login.js
    │   │       └── login.xml
    │   ├── app.css
    │   ├── app.js
    │   └── ...
    └── ...
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>App_Resources</strong>: This folder contains platform-specific resources such as icons, splash screens, and configuration files. The NativeScript CLI takes care of injecting these resources into the appropriate places in the <code>platforms</code> folder when you execute <code>tns run</code>.</li>
<li><strong>shared</strong>: This folder contains any files you need to share across views in your app. In the Groceries app you find a few model objects and a <code>config.js</code> file used to share configuration variables like API keys.</li>
<li><strong>tns_modules</strong>: This folder contains the NativeScript-provided modules you&#39;ll use to build your app. Each module contains platform-specific code (camera, http, file system, etc), exposed through a platform-agnostic API (e.g. <code>http.getJSON()</code>). We&#39;ll look at some examples momentarily.</li>
<li><strong>views</strong>: This folder contains the code to build your app&#39;s views—each of which will have a subfolder in <code>views</code>. Each view is made up of an XML file, a JavaScript file, and an optional CSS file. The groceries app contains three folders for its three views.</li>
<li><strong>app.css</strong>: Contains global styles for your app. We&#39;ll dig into app styling in section 2.3.</li>
<li><strong>app.js</strong>: Sets up your application&#39;s starting module and initializes the app.</li>
</ul>
<p>Let&#39;s start with <code>app/app.js</code>, as it&#39;s the starting point for NativeScript apps. It contains the three lines below: </p>
<pre><code>var application = require(&quot;application&quot;);
application.mainModule = &quot;./views/login/login&quot;;
application.start();
</code></pre><p>Here, you&#39;re requiring, or importing, the <a href="http://docs.nativescript.org/ApiReference/application/HOW-TO">NativeScript application module</a>. Then, you set the main (or start) screen of your app to be the login screen, which lives in your app&#39;s <code>views/login</code> folder.</p>
<blockquote>
<p><strong>Tip</strong>: JavaScript modules in NativeScript follow the <a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS specification</a>. This means you can use the <a href="http://wiki.commonjs.org/wiki/Modules/1.1#Module_Context"><code>require()</code> method</a> to import modules, as is done above, as well as the <code>export</code> keyword, which we&#39;ll look at later in this chapter. These are the same constructs Node.js uses for JavaScript modules, so if you already know how to use Node.js modules, you already know how to use NativeScript modules!</p>
</blockquote>
<p>Now that your app is ready for development, let&#39;s add some UI components to make your login screen show more than just some basic text.</p>
<h3 id="adding-ui-components">Adding UI Components</h3>
<p>Let&#39;s dig into the files used to create your app&#39;s UI, which reside in the <code>app/views</code> folder. Each folder contains one page of your app: <code>list</code>, <code>login</code>, and <code>register</code> are there already. If you look at <code>app/views/login</code>, you&#39;ll see three files: <code>login.css</code>, <code>login.js</code>, and <code>login.xml</code>. Open up the <code>login.xml</code> file. You should see the following code:</p>
<pre><code>&lt;Page&gt;
    &lt;Label text=&quot;hello world&quot; /&gt;
&lt;/Page&gt;
</code></pre><p>This page currently contains two UI components: a <code>&lt;Page&gt;</code> and a <code>&lt;Label&gt;</code>. To make this page look more like a login page, let&#39;s add a few additional components, namely two <code>&lt;TextField&gt;</code>s and two <code>&lt;Button&gt;</code>s.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add UI components to <code>login.xml</code>
</h4>

<p>Replace the existing <code>&lt;Label&gt;</code> with the following code:</p>
<pre><code>&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; /&gt;
&lt;TextField secure=&quot;true&quot; hint=&quot;Password&quot; /&gt;

&lt;Button text=&quot;Sign in&quot; /&gt;
&lt;Button text=&quot;Sign up for Groceries&quot; /&gt;
</code></pre><div class="exercise-end"></div>

<p>NativeScript UI components use attributes to configure their behavior and appearance. The code you just added uses the following attributes:</p>
<ul>
<li><code>&lt;TextField&gt;</code><ul>
<li><code>hint</code>: Used to specify placeholder text into the TextField to show the user what to type</li>
<li><code>secure</code>: Boolean to determine whether the TextField&#39;s text should be masked, which is commonly done on password fields</li>
<li><code>keyboardType</code>: The type of keyboard to present to the user for input. In this case <code>keyboardType=&quot;input&quot;</code> ensures the keyboard in a way optimized for entering email addresses</li>
</ul>
</li>
<li><code>&lt;Button&gt;</code><ul>
<li><code>text</code>: Controls the text displayed within the button</li>
</ul>
</li>
</ul>
<p>Since UI components are visual, you probably want to see what your app looks like. But if you try running the app you won&#39;t see too much:</p>
<p><img src="images/login-stage1-ios.png" alt="login 1">
<img src="images/login-stage1-android.png" alt="login 1"></p>
<p>This app looks off because you need to tell NativeScript how to layout the UI components you place in your page. Let&#39;s look at how to do that next.</p>
<blockquote>
<p><strong>Tip</strong>: You can learn more about the UI components, including a full list of the components and attributes available in <a href="http://docs.nativescript.org/ui-with-xml">the NativeScript docs</a>.</p>
</blockquote>
<h3 id="layouts">Layouts</h3>
<p>NativeScript provides several different layout containers that allow you to place UI components precisely where you want them to appear. </p>
<ul>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/absolute-layout/HOW-TO.html">Absolute Layout</a> lets you position elements using explicit x and y coordinates. This is useful when you need to place elements in exact locations, for instance showing an activity indicator widget in the top-left corner of your app.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/dock-layout/HOW-TO.html">Dock Layout</a> is Useful for placing UI elements at the outer edges of your app. For example, a container docked at the bottom of the screen would be a good container for an ad.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/grid-layout/HOW-TO.html">Grid Layout</a> lets you divide your interface into a series of rows and columns, much like a <code>&lt;table&gt;</code> in HTML markup.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/stack-layout/HOW-TO.html">Stack Layout</a> lets you stack children UI components either vertically or horizontally.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/wrap-layout/HOW-TO.html">Wrap Layout</a> allows child UI components to flow from one row or column to the next when space is filled.</li>
</ul>
<p>In the case of your login screen all you need is a simple <code>&lt;StackLayout&gt;</code> to stack up the elements on the screen. In later sections, you&#39;ll use some of the more advanced layouts.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a stack layout to the login screen</code>
</h4>

<p>In your <code>login.xml</code>, add the <code>&lt;StackLayout&gt;</code> component below directly within the <code>&lt;Page&gt;</code> component. Your <code>login.xml</code> should look something like this:</p>
<pre><code>&lt;Page&gt;
    &lt;StackLayout orientation=&quot;vertical&quot; horizontalAlignment=&quot;center&quot;&gt;
        ... (the two buttons and text fields)
    &lt;/StackLayout&gt;
&lt;/Page&gt;
</code></pre><div class="exercise-end"></div>

<p>The stack layout is a UI component, and as such, it that has attributes just like the <code>&lt;TextField&gt;</code> and <code>&lt;Button&gt;</code> elements you used in the previous section. Here, the <code>orientation=&quot;vertical&quot;</code> attribute tells the stack layout to arrange its child components vertically, and the <code>horizontalAlignment=&quot;center&quot;</code> attribute tells the stack layout to align the child components in the center of the screen.</p>
<p>If you run your app you&#39;ll see that that the elements now all appear, and are stacked up as expected:</p>
<p><img src="images/login-stage2-ios.png" alt="login 2">
<img src="images/login-stage2-android.png" alt="login 2"></p>
<p>However, although the elements stack up as expected, the UI components could use some spacing, and a bit of color to make the app look a bit nicer. To do that let&#39;s look at another NativeScript feature: CSS.</p>
<blockquote>
<p><strong>Tip</strong>: You can learn more about how NativeScript layouts works <a href="http://docs.nativescript.org/layouts">in the NativeScript docs</a> and <a href="https://www.nativescript.org/blog/demystifying-nativescript-layouts">on our blog</a>.</p>
</blockquote>
<h3 id="css">CSS</h3>
<p>NativeScript uses a <a href="http://docs.nativescript.org/styling">subset of CSS</a> for adding styles to your app. There are three mechanisms you can use to add CSS properties to UI components: <a href="http://docs.nativescript.org/styling#application-wide-css">application-wide CSS</a> (<code>app.css</code>), <a href="http://docs.nativescript.org/styling#page-specific-css">page-specific CSS</a>, and an <a href="http://docs.nativescript.org/styling#inline-css">inline <code>style</code> attribute</a>.</p>
<p>As a best practice, place CSS rules that should apply to all pages in your <code>app.css</code>, and CSS rules that apply to a single page in a page-specific CSS file (e.g. <code>login.css</code>). Inline styles are great for quick testing—e.g. <code>&lt;Page style=&quot;background-color: green;&quot;&gt;</code>—but should be avoided in general, as the <code>style</code> attributes tend to clutter up XML files, especially once you need to apply multiple rules.</p>
<p>Let&#39;s start by adding a few application-wide CSS rules.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create global styles
</h4>

<p>Paste the following code in your app&#39;s <code>app.css</code> file:</p>
<pre><code>Page {
    background-color: white;
    font-size: 17;
}
TextField {
    margin: 10;
    background-color: #FAFAFA;
    padding: 10;
}
Button {
    margin: 10;
}
</code></pre><div class="exercise-end"></div>

<p>If you&#39;ve done any web development before, the syntax should feel familiar here; you select three UI components (Page, TextField, and Button) by their tag name, and then apply a handful of CSS rules as name/value pairs. Not all web CSS properties are supported, as some aren&#39;t possible to replicate in native apps without incurring prohibitive performance penalties. A <a href="http://docs.nativescript.org/styling#supported-properties">full list of the CSS properties that are supported</a> are listed on the NativeScript docs.</p>
<blockquote>
<p><strong>Tip</strong>: NativeScript also supports selecting elements by class names and ids. Refer to the docs for <a href="http://docs.nativescript.org/styling#supported-selectors">a full list of the supported selectors</a>.</p>
</blockquote>
<p>With these changes in place, if you run your app you&#39;ll see some nice styles!</p>
<p><img src="images/login-stage3-ios.png" alt="login 3">
<img src="images/login-stage3-android.png" alt="login 3"></p>
<p>Because you placed the above CSS rules in <code>app.css</code>, they&#39;ll apply not only to the login page you&#39;re developing now, but also to the register and list pages you&#39;ll build later in this guide. Before we end our CSS discussion, let&#39;s add one rule that&#39;s specific to the login page.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create page-specific styles
</h4>

<p>Paste the following code in your app&#39;s <code>views/login/login.css</code> file:</p>
<pre><code>Image {
    margin: 20 0;
}
</code></pre><div class="exercise-end"></div>

<p>Here NativeScript follows <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/margin">CSS&#39;s conventions for specifying multiple values in one rule</a>, specifically the first value controls the <code>margin-top</code>/<code>margin-bottom</code>, and the second value controls the <code>margin-left/margin-right</code>. You could alternatively write this CSS as <code>Image { margin-top: 20; margin-bottom: 20; margin-left: 0; margin-right: 0 }</code> if you prefer your code to be more explicit.</p>
<p>For now this CSS does nothing as there is no <code>&lt;Image&gt;</code> UI component on the login page. Let&#39;s change that.</p>
<h3 id="images">Images</h3>
<p>NativeScript supports three different ways to use images within your apps. The first, and simplest, way is to point at the URL of an image:</p>
<pre><code>&lt;Image src=&quot;https://www.nativescript.org/images/default-source/landingpages/logo.png&quot; /&gt;
</code></pre><p>The second way is to point at an image that lives within your app&#39;s <code>app</code> folder. For instance if you have an image at <code>app/images/logo.png</code>, you can use it with:</p>
<pre><code>&lt;Image src=&quot;~/images/logo.png&quot; /&gt;
</code></pre><p>The third way, and the one Groceries uses, is to use platform-specific image resources. Let&#39;s add an image to the login screen and then discuss exactly what&#39;s happening.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a logo
</h4>

<p>In <code>login.xml</code>, add the <code>&lt;Image&gt;</code> below as the first child of the existing <code>&lt;StackLayout&gt;</code> tag:</p>
<pre><code>&lt;Image src=&quot;res://logo&quot; stretch=&quot;none&quot; /&gt;
</code></pre><div class="exercise-end"></div>

<blockquote>
<p><strong>TODO</strong>: Move the discussion below to a blog post where we can go into a lot more detail. I feel like this section should only use the simple method of using images within the app, and then link off to a more thorough discussion.</p>
</blockquote>
<p>The <code>res://</code> syntax tells NativeScript to use a platform-specific resource, in this case an image. You might recall from before that platform-specific resources go in your app&#39;s <code>App_Resources</code> folder, and if you look there you&#39;ll find a few different image files, several of which are named <code>logo.png</code>.</p>
<p>Although more complex than putting an image directly in the <code>app</code> folder, using platform-specific images gives you more control over image display on difference device dimensions. For instance iOS lets you use provide three different image files for devices with different pixel densities. As such you&#39;ll find logos named <code>logo.png</code>, <code>logo@2x.png</code>, and <code>logo@3x.png</code> in your <code>App_Resources/iOS</code> folder. For Android you&#39;ll find similar image files in <code>App_Resources/Android/drawable-hdpi</code> (for &quot;high&quot; dpi, or high dots-per-inch), <code>App_Resources/Android/drawable-mdpi</code> (for medium-dpi), and <code>App_Resources/Android/drawable-ldpi</code> (for low-dpi).</p>
<p>Once these files are in place the NativeScript framework knows how to pick the correct file; all you have to do is reference the image using <code>res://</code> and its base file name—i.e. <code>res://logo</code>. With this change in place here&#39;s what your login screen should look like on iOS and Android:</p>
<p><img src="images/login-stage4-ios.png" alt="login 4">
<img src="images/login-stage4-android.png" alt="login 4"></p>
<p>At this point your UI looks good, but the app still doesn&#39;t actually do anything. Let&#39;s look at how you can use JavaScript to add some functionality.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="application-logic">Application logic</h2>
<p>In this chapter, you&#39;ll learn how to add JavaScript logic to your NativeScript app, and you&#39;ll be doing so using the base pattern on which the NativeScript framework is built, MVVM, or &quot;model, view, view model&quot;. </p>
<ul>
<li>Model: The model defines and represents the data. Separating the model from the various views that may use it allows for code reuse.</li>
<li>View: The view represents the UI, written in XML. The view is often data-bound to the view model so that changes are instantly represented on the presentation tier.</li>
<li>view model: The view model contains the application logic, exposing it for the view. This is the file that is named the same as the view, so in a given folder you will have file.xml and file.js representing the view and the view model, respectively.</li>
</ul>
<p>The most basic benefit of using this sort of separation between the model, view, and view model, is that we are able to craft two-way data binding such that the view model can act as a switchboard between the model and the view. Let&#39;s wire up our login xml to support binding.</p>
<h3 id="the-view-model">The view model</h3>
<p>Although you can now see your login screen as a nicely-styled entity with UI widgets and an image, it&#39;s not yet wired up to send data to the back end. Let&#39;s fix that.</p>
<p>In <code>app/views/login</code>, you&#39;ll find <code>login.js</code>. You&#39;re going to add all the functions that support the xml markup you created in the previous chapter into this file, which will become this page&#39;s view model.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Construct the login view model
</h4>

<p>First, add a &#39;loaded&#39; attribute to the Page element at the top of <code>login.xml</code>:</p>
<pre><code>&lt;Page loaded=&quot;load&quot;&gt;
</code></pre><p>Now you can create a load function in <code>app/views/login/login.js</code>:</p>
<pre><code>exports.load = function() {
    console.log(&quot;hello&quot;)
};
</code></pre><div class="exercise-end"></div>

<blockquote>
<p>The keyword &#39;exports&#39; is standard in CommonJS, on which NativeScript&#39;s implementation of modules is based. In a module, a free variable called &#39;exports&#39; is an object to which a module may add its API as it executes.In this case, using <code>exports</code> in a view model exposes the function for use in the view, or XML file. That is, using <code>exports.foo</code> in the view model is what makes <code>tap=&quot;foo&quot;</code> in the view work. More information can be found on <a href="http://wiki.commonjs.org/wiki/Modules/1.1">the commonjs wiki</a>.</p>
</blockquote>
<p>If you run the app, you can see how, when the login screen loads, you can view the word &#39;hello&#39; in the app console.</p>
<p>With this simple example, you can see how you can append attributes to the xml of the view to run functions in the accompanying JavaScript files. One such attribute is &#39;load&#39;, and another is &#39;tap&#39;.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add tap attributes to the login buttons and add their functions
</h4>

<p>You can add a &#39;tap&#39; attribute that will fire when a button is tapped or touched. </p>
<p>In <code>app/views/login/login.xml</code>, edit the markup for both buttons at the bottom of the screen:</p>
<pre><code>&lt;Button text=&quot;Sign in&quot; tap=&quot;signIn&quot; /&gt;

&lt;Button text=&quot;Sign up for Groceries&quot; tap=&quot;register&quot; /&gt;
</code></pre><p>Then, at the bottom of the <code>app/views/login/login.js</code> file, create the &#39;signIn&#39; and &#39;register&#39; functions:</p>
<pre><code>exports.signIn = function() {
    alert(&quot;Signing in&quot;);
};

exports.register = function() {
    alert(&quot;Registering&quot;);
};
</code></pre><div class="exercise-end"></div>

<p>At this point, if you run your app and tap either of the buttons in your simulator, you will see the appropriate alerts pop up. </p>
<p><img src="images/login-stage5-ios.png" alt="login 5">
<img src="images/login-stage5-android.png" alt="login 5"></p>
<p>Now that you can see tap gestures working, you can make them do something more interesting than open alerts.</p>
<h3 id="navigating-screens">Navigating screens</h3>
<p>When you tap the &quot;Sign Up for Groceries&quot; button, you would expect a navigational change to a registration screen. This is very easy to do in NativeScript.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Enable the &quot;Sign Up&quot; button on the login screen with a navigational change
</h4>

<p>In <code>app/views/login/login.js</code>, add this line to the top of the file:</p>
<pre><code>var frameModule = require(&quot;ui/frame&quot;);
</code></pre><p>Then, replace the current register function with the version shown below:</p>
<pre><code>exports.register = function() {
    var topmost = frameModule.topmost();
    topmost.navigate(&quot;./views/register/register&quot;);
};
</code></pre><div class="exercise-end"></div>

<p>This function makes use of the <a href="http://docs.nativescript.org/ApiReference/ui/frame/README.html">frame module</a> which represents the view that is responsible for navigation in the app. Here, you tell the topmost frame, where the navigation occurs, to navigate to the register view. </p>
<p>If you run your app and click this button, you will be sent to the registration screen, which we have pre-built for you. You can go ahead and create a new account for yourself if you like!</p>
<p><img src="images/navigate-ios.png" alt="navigate">
<img src="images/navigate-android.png" alt="navigate"></p>
<blockquote>
<p>While our Groceries app doesn&#39;t use complex navigation strategies, you have several available to you out of the box such as the <a href="http://docs.nativescript.org/ui-views#tabview">TabView</a> and the <a href="http://docs.nativescript.org/ui-views#segmentedbar">SegmentedBar</a></p>
</blockquote>
<h3 id="accessing-ui-components">Accessing UI components</h3>
<p>Since you have been working with forms in NativeScript, you need to understand how data flows back and forth between the front end and back end. Specifically, you have created a login form, but you need to able to know what is typed into the fields and how to control the look and feel of the fields themselves. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Send data from the front end to the view model
</h4>

<p>To get data to be sent from <code>login.xml</code>, add an id to the email textfield:</p>
<pre><code>&lt;TextField id=&quot;email_address&quot; hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; /&gt;
</code></pre><p>You need to access this textfield via the view, so add a line at the top, underneath the frameModule variable. Also expose email as a variable available to both the load and signIn functions:</p>
<pre><code>var view = require(&quot;ui/core/view&quot;);
var email;
</code></pre><blockquote>
<p>Requiring the <a href="https://docs.nativescript.org/ApiReference/ui/core/view/View.html">view</a> as a module gives you access to the view, which is the base class for all UI components, controlling the layout of a screen. By requiring a view, you can control the properties of both a view and its children.</p>
</blockquote>
<p>Finally, edit the load function in <code>app/views/login/login.js</code> to get a reference to the email address text field:</p>
<pre><code>exports.load = function(args) {
    var page = args.object;
    email = view.getViewById(page, &quot;email_address&quot;);    
};
</code></pre><blockquote>
<p>Note the parameter passed into this function, &#39;args&#39;. These are the children of the view that are laid out onto the screen when the screen is loaded.</p>
</blockquote>
<p>Edit the signIn function to show the data input from the front end:</p>
<pre><code>exports.signIn = function() {
    console.log(email.text)
};
</code></pre><div class="exercise-end"></div>

<p>Now, if you run the app, you&#39;ll find data reaches the view model when the signIn function is run via tapping the signIn button. </p>
<blockquote>
<p>By building JavaScript references to a given UI element, you can control how it looks and behaves on the front end. For example, you can bind a model to a textField and control its target properties:</p>
<pre><code>    var email = view.getViewById(page, &quot;email_address&quot;);
    var model = new observable.Observable();
    model.set(&quot;emailAddress&quot;, &quot;me@myemail.com&quot;);
    var options = {
        sourceProperty: &quot;emailAddress&quot;,
        targetProperty: &quot;text&quot;
    };
    email.bind(options, model);
</code></pre><p><strong>Observables</strong>: Observable is a core building block in the MVVM design pattern. It provides a mechanism used for two-way data binding so as to enable communication between the front and back ends. This means that if the user updates the data in the UI the change will be reflected in the model and vice versa. </p>
</blockquote>
<p>In the next section, we&#39;ll show how to bind data back to the front end.</p>
<h3 id="data-binding">Data binding</h3>
<p>Although you can now see data reaching the view model from the front end XML file, you need to do more than that to actually complete login. The data has to reach a back end service, which for this app is referenced in the model in <code>app/shared/Models/User.js</code>.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Bind data back to the front end
</h4>

<p>You saw how to get data from the front end to the back end, but what if you need to show some pre-filled values in the front end?</p>
<p>To allow for two-way data binding, replace the two existing TextField UI components with the two shown below, which include a new text attribute:</p>
<pre><code>&lt;TextField id=&quot;email_address&quot; text=&quot;{{ email_address }}&quot; hint=&quot;Email Address&quot;  keyboardType=&quot;email&quot; /&gt;
&lt;TextField secure=&quot;true&quot; text=&quot;{{ password }}&quot; hint=&quot;Password&quot; /&gt;
</code></pre><blockquote>
<p>The use of two curly brackets surrounding the text attribute delineates a data-bound value, which will be set by the view model.</p>
</blockquote>
<p>At the top of <code>app/views/login/login.js</code>, edit the top code block to include the following libraries and a new User object, which you&#39;ll be using as this page&#39;s model:</p>
<pre><code>var dialogs = require(&quot;ui/dialogs&quot;);
var frameModule = require(&quot;ui/frame&quot;);
var User = require(&quot;../../shared/models/User&quot;);

var user = new User();
</code></pre><blockquote>
<p>You need to include the dialog module so that later on, we can show a more complex popup than an alert can give us. You&#39;ll use it later.</p>
</blockquote>
<p>Now, edit the load function to hard-code some values that will show up on the front end:</p>
<pre><code>exports.load = function(args) {

    var page = args.object;

    user.set(&quot;email_address&quot;, &quot;tj.vantoll@gmail.com&quot;);
    user.set(&quot;password&quot;, &quot;password&quot;);

    page.bindingContext = user;

};
</code></pre><p>What&#39;s going on here?</p>
<ul>
<li>First, we&#39;re setting the user object&#39;s email_address and password properties to a hard-coded value so that we can see them on the frontend and thereby give a visible prompt to our users and a quick way to login.</li>
<li>Then, we bind the elements of the page whose arguments are passed to this load function to these values</li>
<li>The values appear as bound values on the front end as delineated by the curly brackets you added above</li>
</ul>
<div class="exercise-end"></div>

<p>If you run your app, you&#39;ll see the fields prefilled:</p>
<p><img src="images/login-stage5-ios.png" alt="login 5">
<img src="images/login-stage5-android.png" alt="login 5"></p>
<p>Now that you have the ability to bind the front end to the back end, you need to be able to send that data to a database in order to complete the login routine. In the next chapter, you will connect the view and the view model to a back end service via the model.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="nativescript-modules">NativeScript modules</h2>
<p>In the previous chapter, you already saw how NativeScript leverages the concept of &#39;modules&#39; to include bits of code that are kept in the <code>tns_modules</code> folder. Using <code>require()</code>, you can include these snippets ad hoc in your code when you need to use them, similar to the way you use npm to import node libraries. Let&#39;s take a closer look at these modules and what they can do for your app.</p>
<blockquote>
<p>If you dig a bit into the tns_modules folder and find the http folder, you can see how a NativeScript module is constructed. It includes:</p>
<ul>
<li>a package.json file that sets the name of the module and includes the base file that defines the module.</li>
<li>a file containing android native code (http-request.android.js).</li>
<li>a file containing ios native code (http-request.ios.js).</li>
<li>a generic file (http.js) that abstracts the platform-specific code above into a platform-agnostic API so that you can make HTTP calls on both platforms using a single JavaScript API.</li>
</ul>
<p>A note about platform-specific files: Any file, whether XML, CSS, or JavaScript, in NativeScript can have a platform-specific file and will be named accordingly. These files are included on an ad hoc basis when NativeScript compiles an app - for an iOS app, the ios file is included, and for Android, the android version is included. These files contain native code to manage device-specific actions, but a platform-specific file written in XML or CSS might contain code to make the presentation layer behave or look differently on a different platform. We&#39;ll explore this method in detail below.</p>
</blockquote>
<p>More information on modules can be found <a href="http://developer.telerik.com/featured/nativescript-works/">here</a>.</p>
<h3 id="connecting-the-model-to-the-back-end-with-the-http-module">Connecting the model to the back end with the http module</h3>
<p>You probably noticed, if you created your own user on the registration page, that data was passing magically...somewhere. There&#39;s actually no magic involved; there is a config file that contains an API Key to <a href="http://www.telerik.com/backend-services">Telerik BackEnd Services</a>, where we are storing our users&#39; information. You don&#39;t have to use Telerik Backend Services; you can connect to any back end endpoint you like! The Groceries app just happens to use the Telerik endpoint.</p>
<p>Take a look at <code>app/shared/config.js</code>. There&#39;s only a small code snippet there, but it includes a hard-coded API Key that we use throughout the app to access the back end (in real life, you would of course use your own API Key):</p>
<pre><code>module.exports = {
    apiUrl: &quot;http://api.everlive.com/v1/GWfRtXi1Lwt4jcqK/&quot;
};
</code></pre><p>Take a look in <code>app/shared/models</code>. Normally, models use a service to connect to and communicate with a back end. In this case, the connection code is added directly into the model for simplicity. You can see this demonstrated in the registration function.</p>
<p>Note that the config file is used in all the model files, for example in User model: <code>app/shared/models/User.js</code>:</p>
<pre><code>var config = require(&quot;../../shared/config&quot;);
</code></pre><h4 class="exercise-start">
    <b>Exercise</b>: Complete the login in the model
</h4>

<p>To complete the login of a user, in <code>app/shared/Models/Users.js</code>, under the line where you require <code>config</code>, you need to require <a href="http://docs.nativescript.org/ApiReference/http/README.html">the http module</a>. This module allows the app to communicate with an external endpoint over HTTP.</p>
<pre><code>var http = require(&quot;http&quot;);
</code></pre><p>Now you can build out the login function. Paste in the following code in between the login function brackets:</p>
<pre><code>    var that = this;
    return new Promise(function(resolve, reject) {
        http.request({
            url: config.apiUrl + &quot;oauth/token&quot;,
            method: &quot;POST&quot;,
            content: JSON.stringify({
                username: that.get(&quot;email_address&quot;),
                password: that.get(&quot;password&quot;),
                grant_type: &quot;password&quot;
            }),
            headers: {
                &quot;Content-Type&quot;: &quot;application/json&quot;
            }
        }).then(function(data) {
            config.token = data.content.toJSON().Result.access_token;
            resolve();
        }).catch(function() {
            reject();
        });
    });
</code></pre><p>What&#39;s going on here? </p>
<ul>
<li><p>First, you alias the <code>this</code> variable by assigning it to a private variable, <code>that</code>. This allows you to continue to access the original value of <code>this</code> in inner functions</p>
</li>
<li><p>Second, you return a new Promise, which primarily allows the caller ofthis function to execute code after the asynchronous login either completes successfully or fails.</p>
</li>
</ul>
<blockquote>
<p><strong>Promises</strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a> are a part of ECMAScript 6 (the scripting language of which JavaScript is an implementation) that have been implemented in Google&#39;s V8 engine and JavaScriptCore framework (which provides a JavaScript engine for WebKit) and are thereby available in NativeScript apps.</p>
</blockquote>
<ul>
<li><p>Next, you use the http module&#39;s <a href="http://docs.nativescript.org/ApiReference/http/HttpRequestOptions.html"><code>request()</code> method</a> to POST data to the <code>apiUrl</code> that is set up in config. The username, password and grant_type are sent to this endpoint as a JSON string. Telerik Backend Services <a href="http://docs.telerik.com/platform/backend-services/development/rest-api/users/authenticate-user">uses the parameter of grant_type</a> for login.</p>
</li>
<li><p>Finally, the endpoint&#39;s response is handled. <code>Http.request()</code> returns a Promise, which this code uses to either resolve or reject its own Promise. When the request is successful, the code saves a reference to the user&#39;s authentication token to be used on subsequent requests.</p>
</li>
</ul>
<div class="exercise-end"></div>

<h3 id="dialog-module">Dialog module</h3>
<p>The dialog module can be used to show <a href="http://docs.nativescript.org/ApiReference/ui/dialogs/HOW-TO.html">several types</a> of popup UIs in your app, including action, confirm, alert, login, and prompt dialogs. It is a highly customizable module so that you can provide good prompts to your users, and it allows you to control the buttons you include int he alert, their text, and the messaging in the alert itself. Its code is found in the tns_modules/ui folder with other UI widgets.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Handle an error with a dialog window
</h4>

<p>Allow the view model to invoke the login function that you just added to the model. In  <code>app/views/login/login.js</code> rewrite your <code>signIn()</code> function to look like this:</p>
<pre><code>exports.signIn = function() {
    user.login()
        .then(function() {

        }).catch(function() {
            dialogs.alert({
                message: &quot;Unfortunately we could not find your account.&quot;,
                okButtonText: &quot;OK&quot;
            });
        });
};
</code></pre><div class="exercise-end"></div>

<p>What&#39;s happening here? In this case, the <code>login()</code> function uses the Promise approach that is returned by the login prototype in <code>app/shared/models/User.js</code> to handle both a successful and an unsuccessful login. If the login is unsuccessful, we show a dialog with a popup button stating that your account can&#39;t be found.</p>
<p>Now that you are able to handle an unsuccessful login, you need to allow people to view their grocery list after they successfully login. Once the user logs in, you can use the &quot;list&quot; page to facilitate adding and removing groceries to and from a list. To do that, you need a module that will show items in a list, which is exactly what the ListView does.</p>
<h3 id="listview">ListView</h3>
<p>Let&#39;s use another UI module to craft a page to actually hold our grocery data. This is the page we want users to navigate to once they login, so let&#39;s add a line in <code>app/views/login/login.js</code> to allow this navigation to happen. In the <code>signIn()</code> function you edited above, add the following line after <code>.then(function(){</code>:</p>
<pre><code>frameModule.topmost().navigate(&quot;./views/list/list&quot;);
</code></pre><p>Now, if you rebuild and run your app in an emulator, you can login either using your credentials that you created earlier, or TJ&#39;s:</p>
<p><img src="images/login-stage6-ios.png" alt="login 6">
<img src="images/login-stage6-android.png" alt="login 6"></p>
<p>You&#39;ll find that after you login, you&#39;re sent to a blank screen. You&#39;re going to build a list to hold grocery data next. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Construct the list view
</h4>

<p>In <code>app/views/list/list.xml</code>, let&#39;s get started using the ListView module by creating a list where our groceries will reside:</p>
<pre><code>&lt;Page navigatedTo=&quot;navigatedTo&quot;&gt;
    &lt;GridLayout&gt;        
        &lt;ListView items=&quot;{{ groceryList }}&quot;&gt;
            &lt;ListView.itemTemplate&gt;
                &lt;Label text=&quot;{{ name }}&quot; horizontalAlignment=&quot;left&quot; verticalAlignment=&quot;center&quot;/&gt;
            &lt;/ListView.itemTemplate&gt;
        &lt;/ListView&gt;
    &lt;/GridLayout&gt;
&lt;/Page&gt;
</code></pre><div class="exercise-end"></div>

<blockquote>
<p>navigatedTo: The navigatedTo function that is called during the navigation event allows data to pass from one page to another when navigation is occurring. In this case, the navigatedTo function in <code>app/views/list/list.js</code> will set the page title for iOS, sets up the deletion module, sets up binding, and empties and reloads the list. You&#39;ll build this functionality below.</p>
</blockquote>
<p>Note the use of the ListView module. In this case, we&#39;re not requiring a tns_module from the ui folder, but are rather using the ui widget within the xml code. This is a different way to use these modules. </p>
<p>If you wanted to, you could construct a ListView in pure JavaScript code behind the scenes as shown in <a href="http://docs.nativescript.org/ApiReference/ui/list-view/HOW-TO.html">this example</a>. However for now, you can simply use xml to build the ListView and thereby follow the pattern you use in the login and register screens.</p>
<p>Finally, note the ListView&#39;s use of an itemTemplate. Using an itemTemplate gives you more control over how the actual items look within the list.</p>
<blockquote>
<p>Tip: Other modules
There are several modules that come out of the box with your NativeScript install, including a location service, a file-system helper, timer, camera, and even a color module that helps navigate the ways various colors are handled cross-platform. If you are interested in helping build and distribute more modules for the community, there&#39;s a <a href="http://developer.telerik.com/featured/building-your-own-nativescript-modules-for-npm/">good guide</a> available on how to do this.</p>
</blockquote>
<p>If you were to run this code as it stands, you wouldn&#39;t see any items in the grocery list. You need to build out a way to manage data within the ListView module.</p>
<h3 id="working-with-arrays">Working with arrays</h3>
<p>To be able to manage data in the grocery list, you need to build a connection between the presentation tier and the database as you did for login. Go ahead and build out these pieces in your grocery list.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Populate the list view
</h4>

<p>In app/views/list/list.js, add:</p>
<pre><code>var GroceryList = require(&quot;../../shared/models/GroceryList&quot;);

var page;
var pageData = new observable.Observable();
var groceryList = []; // create an empty array
var tmpList = [&quot;eggs&quot;,&quot;bread&quot;,&quot;cereal&quot;];

for (var i = 0, size = tmpList.length; i &lt; size ; i++) {
        groceryList.push({id: i, name: tmpList[i]});
    }

pageData.set(&quot;groceryList&quot;, groceryList);


exports.navigatedTo = function(args) {
    page = args.object;
    page.bindingContext = pageData;

};
</code></pre><p>Here, you&#39;re creating a new empty grocery array and, for the moment, populating it with some grocery items. You can see how this data is pulled into the page when you navigate to this page via the pageData observable object.</p>
<p>Now if you were to run this code in the emulator, you would see a list of your hard-coded values:</p>
<p>&lt;&gt;images</p>
<p>You need, however, to load up any grocery items that exist in the database to which you just logged in, however, so edit the code above to change the hard-coded values into an object that references the model:</p>
<pre><code>var GroceryList = require(&quot;../../shared/models/GroceryList&quot;);

var page;
var pageData = new observable.Observable();
var groceryList = new GroceryList();

pageData.set(&quot;groceryList&quot;, groceryList);

exports.navigatedTo = function(args) {
    page = args.object;
    page.bindingContext = pageData;

    groceryList.empty();
    groceryList.load();
};
</code></pre><p>In this code, groceryList is now referencing the grocery list model and in the navigatedTo function, the groceryList object is emptied and then reloaded from the database so that the data remains current.  </p>
<p>Now you should build out the <code>empty()</code> and <code>load()</code> functions in the model so that we can get this data from the database.</p>
<p>In <code>app/shared/models/GroceryList.js</code>, grab any Grocery data that might exist in the back end and push it into the grocery array:</p>
<pre><code>GroceryList.prototype.load = function() {
    var that = this;
    http.getJSON({
        url: config.apiUrl + &quot;Groceries&quot;,
        method: &quot;GET&quot;,
        headers: {
            &quot;Authorization&quot;: &quot;Bearer &quot; + config.token
        }
    }).then(function(data) {
        data.Result.forEach(function(grocery) {
            that.push({
                name: grocery.Name,
                id: grocery.Id
            });
        });
    });
};
GroceryList.prototype.empty = function() {
    while (this.length) {
        this.pop();
    }
};
</code></pre><div class="exercise-end"></div>

<p>In the load function above, you are pulling down the list associated to the user&#39;s credentials. In the empty function, you clear out the array and get ready to reload it. If you rebuild, run the app, and login as tj.vantoll@gmail.com, you&#39;ll find a list of groceries pulled from Backend Services in the Groceries data type. It will look something like this:</p>
<p><img src="images/list-ios.png" alt="list ios">
<img src="images/list-android.png" alt="list android"></p>
<p>It&#39;s great that you can see data already in the database, but you also need to add some items. Go ahead and build that functionality.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add the ability to create a Grocery item
</h4>

<p>First, add another parameter to the pageData observable object as an empty placeholder in <code>app/views/list/list.js</code> above the line: <code>pageData.set(&quot;groceryList&quot;, groceryList);</code>:</p>
<pre><code>pageData.set(&quot;grocery&quot;, &quot;&quot;);
</code></pre><p>Edit the list view xml to allow for a two column layout with a text field and a button to add grocery items. Change the GridLayout in <code>app/views/list/list.xml</code> initial tag to account for this layout:</p>
<pre><code>&lt;GridLayout rows=&quot;auto, *&quot; columns=&quot;*, *, *&quot;&gt;
</code></pre><blockquote>
<p>This layout will include two rows, one auto-sized according to its children&#39;s dimensions, and the other stretchable to allow for the expanding list. It will have three auto-stretching columns as the text field will occupy two columns and the button one column.</p>
</blockquote>
<p>Add a text field and a button to have a place to enter grocery items. The text field will have the id &#39;grocery&#39; and is bound to the grocery object, has a hint that will show on the front end to help the user, will occupy one row and two columns. The button will have a tap event - <code>tap</code> and will occupy the initial row as well and the third column - remember numbering of rows and columns starts at zero. Add these two lines after the GridLayout initial tag:</p>
<pre><code>    &lt;TextField id=&quot;grocery&quot; text=&quot;{{ grocery }}&quot; hint=&quot;Enter a grocery item&quot; row=&quot;0&quot; colspan=&quot;2&quot; /&gt;
    &lt;Button text=&quot;Add&quot; tap=&quot;add&quot; row=&quot;0&quot; col=&quot;2&quot;&gt;&lt;/Button&gt;
</code></pre><p>Finally, edit the <code>&lt;ListView&gt;</code> tag to ensure that it will expand across the new columns you created:</p>
<pre><code>&lt;ListView items=&quot;{{ groceryList }}&quot; id=&quot;groceryList&quot; row=&quot;1&quot; colSpan=&quot;3&quot;&gt;
</code></pre><p>Now you are ready to build the add tap event.</p>
<p>In app/views/list/list.js, add a function to respond to the &#39;add&#39; tap event that you just added. You&#39;ll put this underneath the navigatedTo function.</p>
<pre><code>exports.add = function() {
    //check for empty submission
    if (groceryList.isValidItem(pageData.get(&quot;grocery&quot;))) {
        //dismiss the keyboard
        view.getViewById(page, &quot;grocery&quot;).dismissSoftInput();
        groceryList.add(pageData.get(&quot;grocery&quot;))
            .catch(function() {
                dialogs.alert({
                    message: &quot;An error occurred adding to your list.&quot;,
                    okButtonText: &quot;OK&quot;
                });
            });
        //empty the input field
        pageData.set(&quot;grocery&quot;, &quot;&quot;);
    } else {
        dialogs.alert({
            message: &quot;Please enter a grocery item&quot;,
            okButtonText: &quot;OK&quot;
        });
    }
};
</code></pre><p>In this function, you test for an empty value, and if this test passes, dismiss the keyboard, then get the &#39;grocery&#39; item from the input field and add it to the groceryList object. </p>
<p>Finally, let the manipulation of this new data be handled in the model by adding the following function under the &#39;empty&#39; function in /app/shared/models/GroceryList.js:</p>
<pre><code>GroceryList.prototype.add = function(grocery) {
    var that = this;
    return new Promise(function(resolve, reject) {
        http.request({
            url: config.apiUrl + &quot;Groceries&quot;,
            method: &quot;POST&quot;,
            content: JSON.stringify({
                Name: grocery
            }),
            headers: {
                &quot;Authorization&quot;: &quot;Bearer &quot; + config.token,
                &quot;Content-Type&quot;: &quot;application/json&quot;
            }
        }).then(function() {
            that.push({ name: grocery });
            resolve();
        }).catch(function() {
            reject();
        });
    });
};
</code></pre><div class="exercise-end"></div>

<p>If you build and rerun your app now, you&#39;ll find that you can add a grocery item and it will appear immediately in your list.</p>
<p>Now that you have login, registration, and list routines complete, you can enhance the app&#39;s functionality as a grocery list management tool. You can use the NativeScript Social Sharing plugin to get the data you input into an email so you can send yourself a reminder to pick up your groceries.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="plugins-and-npm-modules">Plugins and npm modules</h2>
<p>Often, you need to include plugins and/or modules that are not by default available in the <code>tns_modules</code> folder to enable special functionality in your app. You can leverage <a href="https://www.npmjs.com/">npm</a>, node package manager, to import plugins and modules into your project. Alternately, you can install NativeScript plugins, which are simply npm modules that can access native code and leverage Android and iOS SDKs if required. </p>
<p>In this section, you&#39;ll install and use an external module, an email validator, so that you can check email addresses for validity as they are entered in the login screen. Then, you&#39;ll add a NativeScript plugin, the <a href="https://www.npmjs.com/package/nativescript-social-share">NativeScript Social Share widget</a>, to manage sharing grocery lists. </p>
<h3 id="using-a-npm-module-in-your-app">Using a npm module in your app</h3>
<p>It would be nice to be able to make sure people are entering well-formatted email addresses into your app in the registration screen, so you can use a basic npm module from the npm registry to avoid having to write this functionality yourself. You can <a href="https://www.npmjs.com/package/email-validator">use this validator</a> to test for valid addresses.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Install and use an email validator
</h4>

<p>Make sure that you are working in the root directory in your Groceries project folder, a.k.a. here:</p>
<p>my-project &lt;----------------
    ├── app
    │   └── ...
    ├── package.json
    └── platforms
        ├── android
        └── ios </p>
<p>and install the module:</p>
<pre><code>npm install email-validator --save
</code></pre><p>What just happened? The install process does a few things in the background. First, it adds a line to <code>app/package.json</code> because you added the <code>--save</code> flag to the above command:</p>
<pre><code>&quot;dependencies&quot;: {
        &quot;email-validator&quot;: &quot;^1.0.2&quot;
    }
</code></pre><p>Then, the NativeScript CLI adds a folder to the <code>node_modules</code> in the root called <code>email-validator</code>. In this folder is the code used by the module, in this case a small regex check in <code>app/node_modules/email_validatorindex.js</code>. </p>
<p>You&#39;re going to add this functionality to our list of groceries, so in <code>/app/shared/models/User.js</code>, require the module:</p>
<pre><code>var validator = require(&quot;email-validator/index&quot;);
</code></pre><blockquote>
<p>In this case, we need to explicitly point to the index.js file, because normally NativeScript is configured to look in an npm module&#39;s package.json file for the &quot;main&quot; value to reference a file, like <code>index.js</code>. In the case of this particular module, the <code>main</code> value is simply <code>index</code> so you need to reference the main file directly.</p>
</blockquote>
<p>To make use of this validator, add a function to <code>app/models/User.js</code> under the register function:</p>
<pre><code>User.prototype.isValidEmail = function() {
    var email = this.get(&quot;email_address&quot;);
    return validator.validate(email);
};
</code></pre><p>Then, edit the registration function in <code>app/views/register/register.js</code> to trap any malformed email addresses:</p>
<pre><code>exports.register = function() {
    if (user.isValidEmail()) {
        completeRegistration();
    } else {
        dialogs.alert({
            message: &quot;Please include a valid email address.&quot;,
            okButtonText: &quot;OK&quot;
        });
    }
};
</code></pre><p>In this code, the user submits an email and password, and the value is sent to the model for validation. If it passes, registration can proceed, otherwise an alert is shown:</p>
<p><img src="images/email-validate-ios.png" alt="share">
<img src="images/email-validate-android.png" alt="share"> </p>
<div class="exercise-end"></div>

<h3 id="using-a-nativescript-plugin-in-your-app">Using a NativeScript plugin in your app</h3>
<p>In order to email grocery lists via your app, you need to install the Social Sharing plugin, with which you can share both text and images. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Install and use the Social Sharing widget
</h4>

<p>To install this plugin, all you need to do is type:</p>
<pre><code>tns plugin add nativescript-social-share
</code></pre><p>What just happened? The install process does the same thing that an <code>npm install</code> command does, in that it writes the dependency to <code>package.json</code>, and it also configures any native code that the plugin needs to use. </p>
<p>Now, include the social share plugin at the top of <code>app/views/list/list.js</code> using <code>require()</code>:</p>
<pre><code>var socialShare = require(&quot;nativescript-social-share&quot;);
</code></pre><p>Now, make an area at the top of <code>app/views/list/list.xml</code> file to show a link to share a grocery list. Under the <Page> tag, add the following code. Once you build the <code>share()</code> function, tapping this link will open a native email sharing widget:</p>
<pre><code>&lt;Page.actionBar&gt;
        &lt;ActionBar title=&quot;Groceries&quot;&gt;
            &lt;ActionBar.actionItems&gt;
                &lt;ActionItem text=&quot;Share&quot; tap=&quot;share&quot; ios.position=&quot;right&quot; /&gt;
            &lt;/ActionBar.actionItems&gt;
        &lt;/ActionBar&gt;
&lt;/Page.actionBar&gt;
</code></pre><p>You have now added an <a href="https://docs.nativescript.org/ApiReference/ui/action-bar/ActionBar">ActionBar</a>, which is a UI component that includes various menu items, enclosed in the <code>&lt;ActionBar.actionItems&gt;</code> tag. The title of the ActionBar allows page-specific titles to be displayed.</p>
<blockquote>
<p>Note, on iOS devices, action bar items are placed from left to right in sequence, so you can override that by specifying an icon&#39;s position.</p>
</blockquote>
<p>Now you need to get your grocery list into a comma-delimited format and feed it to the socialSharing widget. To do this, add a function to return our list at the bottom of <code>/app/views/list/list.js</code>:</p>
<pre><code>exports.share = function() {
    var list = [];
    var finalList = &quot;&quot;;
    for (var i = 0, size = groceryList.length; i &lt; size ; i++) {
        list.push(groceryList.getItem(i).name);
    }
    var listString = list.join(&quot;, &quot;).trim();
    socialShare.shareText(listString);
};
</code></pre><p>With this code, you are taking the <code>name</code> key of your groceryList object and converting it to a comma-delimited string to use in an email.</p>
<div class="exercise-end"></div>


<p>Now when you run the app, you&#39;ll see a Share button at the top that, when clicked, allows you to email a list using a native interface:</p>
<p><img src="images/share-view-ios.png" alt="share">
<img src="images/share-email-ios.png" alt="share">
<img src="images/share-view-android.png" alt="share">
<img src="images/share-email-android.png" alt="share"></p>
<p>You can learn more about modules and plugins <a href="https://www.nativescript.org/blog/using-npm-modules-and-nativescript-plugins">here</a>.</p>
<blockquote>
<p><strong>Tip:</strong> It&#39;s very cool to add ready-built modules to your app. You can search for NativeScript plugins <a href="https://www.npmjs.com/search?q=nativescript">here</a> and find a good variety of supported npm modules <a href="https://github.com/NativeScript/NativeScript/wiki/supported-npm-modules">here</a>. But maybe you want to build your own! Read more on how to do this <a href="http://developer.telerik.com/featured/building-your-own-nativescript-modules-for-npm/">here</a>.</p>
</blockquote>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="accessing-native-apis">Accessing native APIs</h2>
<p>The beauty of NativeScript is that you can write a native iOS or Android app in JavaScript, XML, and CSS without touching Swift, Objective-C, or Java, if you choose. But what if you want to present a different, more platform-specific UI to your users? In the case of this app, deleting an item from your groceries list would be a valid and common use case. </p>
<p>Sliding to delete a list item seems like a great gesture to support. But since you want to make this app feel as native as possible, it&#39;s better to fork your code at this point to provide a more platform-specific experience. So to enable a user to delete an item from a list, create a slide-to-delete UI for iOS, and use an Android-style &#39;trash can&#39; icon for an Android.</p>
<blockquote>
<p>Learn more about how the NativeScript API leverages native code <a href="http://developer.telerik.com/featured/nativescript-works/">here</a></p>
</blockquote>
<h3 id="deleting-from-a-list-android">Deleting from a list - Android</h3>
<p>Earlier, you saw how any element in a NativeScript app can have Android vs. iOS attributes, either by adding such an attribute directly in the code or creating separate .js, .css, or .xml files. To create a separate delete mechanism for this app, you will both all of these strategies.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Edit the List View
</h4>

<p>For Android, you are going to add an icon that will be hidden on iOS. To account for this button, you also need to edit the layout of the ListView, so replace the current ListView code in <code>app/views/list/list.xml</code> with the following:</p>
<pre><code>&lt;ListView items=&quot;{{ groceryList }}&quot; id=&quot;groceryList&quot; row=&quot;1&quot; colSpan=&quot;3&quot;&gt;
    &lt;ListView.itemTemplate&gt;
        &lt;GridLayout columns=&quot;*, auto&quot;&gt;
            &lt;Label text=&quot;{{ name }}&quot; horizontalAlignment=&quot;left&quot; verticalAlignment=&quot;center&quot;/&gt;
            &lt;Image src=&quot;res://ic_menu_delete&quot; ios:visibility=&#39;collapsed&#39; margin=&quot;10&quot; col=&quot;1&quot; tap=&quot;delete&quot;/&gt;
        &lt;/GridLayout&gt;
    &lt;/ListView.itemTemplate&gt;
&lt;/ListView&gt;
</code></pre><p>In this code, you have created:</p>
<ul>
<li>an itemTemplate, in which you can format the rows of your list view. In this itemTemplate you have nested a GridLayout with two columns, one stretched and one expanding only to the width of the child. </li>
<li>a label that contains the name of the grocery item is added to one column and aligned left. </li>
<li>an image, the delete icon, that is hidden from ios devices, placed in the right-hand column, and given a tap event. The image itself has already been placed in the app for you, and can be found in the platforms folder in the drawable folders in <code>platforms/android/bin/res</code>.</li>
</ul>
<div class="exercise-end"></div>

<p>Now that you have built the interface for Android&#39;s tappable icon, add a way for a swipe delete interface to be shown on iOS.</p>
<h3 id="deleting-from-a-list-ios">Deleting from a list - iOS</h3>
<p>There is already a module ready-built for you to use to enable a swipe-to-delete gesture within a list view. Take a look in <code>shared/utils/ios-swipe-delete.js</code>. The code  </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Edit the List View
</h4>

<p>Include this library into <code>app/views/list/list.js</code> at the top, under the inclusion of the social share plugin:</p>
<pre><code>var swipeDelete = require(&quot;../../shared/utils/ios-swipe-delete&quot;);
</code></pre><p>Then, add this code to the <code>navigatedTo()</code> function under <code>page = args.object;</code>:</p>
<pre><code>if (page.ios) {
        //set the page title for iOS
        page.ios.title = &quot;Groceries&quot;;
        var listView = view.getViewById(page, &quot;groceryList&quot;);
        swipeDelete.enable(listView, function(index) {
            groceryList.delete(index);
        });
    }
</code></pre><div class="exercise-end"></div>

<p>That&#39;s all you have to do to enable swipe-to-delete for iOS! What this code does is use this functionality from the included utility, invoking the <code>enable()</code> function from the swipeDelete utility for the referenced listView, and flagging the index of the list to be deleted. At this point, all that remains to accomplish the deletion is to build the <code>delete()</code> function.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Build the delete function
</h4>

<p>First, create a <code>delete()</code> function in <code>app/views/list/list.js</code> at the bottom of this file, under the <code>share()</code> function:</p>
<pre><code>exports.delete = function(args) {
    var item = args.view.bindingContext;
    var index = groceryList.indexOf(item);
    groceryList.delete(index);
};
</code></pre><p>This code reads in the item that is tapped via the arguments passed into the function, matches that item to the index in the groceryList object, and sends that index to be deleted. It remains only to implement the actual deletion in the model.</p>
<p>In <code>app/shared/models/GroceryList.js</code>, add a function to delete an item:</p>
<pre><code>GroceryList.prototype.delete = function(index) {
    var that = this;
    return new Promise(function(resolve, reject) {
        http.request({
            url: config.apiUrl + &quot;Groceries/&quot; + that.getItem(index).id,
            method: &quot;DELETE&quot;,
            headers: {
                &quot;Authorization&quot;: &quot;Bearer &quot; + config.token,
                &quot;Content-Type&quot;: &quot;application/json&quot;
            }
        }).then(function() {
            that.splice(index, 1);
            resolve();
        }).catch(function() {
            reject();
        });
    });
};
</code></pre><p>Similar to code elsewhere in the models, as you have seen, an item is passed to the function and a Promise is returned. Data is sent to Backend Services, including a URL with the id of the item to be deleted appended, the method (DELETE), and headers which include the token saved after the user logs in. If the deletion is successful, item is removed from the grocery list observable that feeds the list view. </p>
<div class="exercise-end"></div>

<p>You&#39;ve created a functional, cross-platform app to manage your grocery list! In the process you created a unique UI for Android and iOS, leveraged plugins and npm modules, learned how to login and register, managed backend services, create a functioning list with add and delete options, and more. Congratulations!</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="next-steps">Next steps</h2>
<p>...</p>
<h3 id="documentation">Documentation</h3>
<p>...</p>
<h3 id="showcase">Showcase</h3>
<p>...</p>

		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>