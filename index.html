<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>NativeScript Quick Start</title>

	<meta charset="utf-8">
	<meta name="description" content="A quick-start guide for NativeScript CLI apps">
	<meta name="author" content="TJ VanToll, Jen Looper">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="header">
	<a href="#" class="menu header-btn" id="toggle-toc"></a>
	<h1>NativeScript Quick Start</h1>
	<a href="https://github.com/NativeScript/quick-start" class="github header-btn"></a>
</div>

<div id="container">
	<div id="toc">
		<div class="author">By <a href="http://tjvantoll.com">@tjvantoll</a>, <a href="http://www.ladeezfirstmedia.com">@jenlooper</a></div>
		<div id="toc-padding"></div>
	</div>
	<div id="book">
		<div class="chapter">
			<h2 id="introduction">Introduction</h2>
<p style="color: red;">
    <b>Warning:</b> The guide you see here is a work in progress. You are welcome to go through the guide, but please keep in mind the guide is not complete; it has not been proofread; and there are certainly errors. If you have any high-level feedback on the guide feel free to document it on <a href="https://github.com/NativeScript/quick-start/issues">our issue tracker</a>.
</p>

<p>Welcome to the <a href="https://nativescript.org">NativeScript</a> Getting Started Guide. Using this guide, you&#39;ll use NativeScript, a cross-platform JavaScript framework for building native mobile apps, to build an iOS and Android app from scratch.</p>
<p><img src="images/nativescript-logo.jpg" alt="NativeScript.org logo"></p>
<h3 id="what-you-re-building">What you&#39;re building</h3>
<p>Here&#39;s the premise: your boss has tasked you with creating the next great grocery management app. You&#39;re given some designs from your design team, a few HTTP endpoints from your backend team, and you&#39;re told to build an app that does the following things:</p>
<ul>
<li>Allows users to register and login.</li>
<li>Allows authenticated users to add and delete groceries from a list.</li>
<li>Connects to your companies&#39; existing RESTful services.</li>
<li>Meets your design team&#39;s “native” mockups.</li>
<li>Runs cross-platform—i.e. iOS and Android.</li>
<li>Runs cross-device—i.e. phones and tablets.</li>
</ul>
<p>This guide will walk you through building an app that meets these requirements and more. If you follow along to the end here&#39;s what the finished app looks like on iOS:</p>
<p><img src="images/login-screenshot.png" alt="login">
<img src="images/register-screenshot.png" alt="register">
<img src="images/list-screenshot.png" alt="list"></p>
<p>And here&#39;s what the app looks like on Android:</p>
<p><img src="images/screenshot-placeholder.png" alt="placeholder">
<img src="images/screenshot-placeholder.png" alt="placeholder">
<img src="images/screenshot-placeholder.png" alt="placeholder"></p>
<p>By building “Groceries“ you&#39;ll see just how easy NativeScript makes building iOS and Android apps—and fun too! Let&#39;s get started.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="getting-up-and-running">Getting up and running</h2>
<p>There are two ways to use NativeScript: through the NativeScript Command-Line Interface (CLI) and through <a href="http://www.telerik.com/appbuilder">Telerik AppBuilder</a>. Although the NativeScript framework itself is the same regardless of whether you use the CLI or AppBuilder, the way you interface with NativeScript—how you run your app, how you change configuration files, and so forth—differs based on the interface you choose.</p>
<p>For this guide, we&#39;re assuming that you are going to develop your app on your local computer using the NativeScript CLI. Although most of the steps and advice given in this guide apply equally to using NativeScript through the CLI or AppBuilder, some—mostly related to development workflow—are specific to using NativeScript through the NativeScript CLI.</p>
<h3 id="install-nativescript-and-configure-your-environment">Install NativeScript and configure your environment</h3>
<p>The NativeScript CLI has a few system requirements you must complete before building NativeScript apps. As a first step start by going through the appropriate instructions below depending on your development machine&#39;s operating system:</p>
<ul>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-win.html">Windows</a></li>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-os-x.html">OS X</a></li>
<li><a href="http://docs.nativescript.org/setup/ns-cli-setup/ns-setup-linux.html">Linux</a></li>
</ul>
<p>Once you have the setup complete, use the <code>npm install</code> command to install the NativeScript CLI itself:</p>
<pre><code>$ npm install -g nativescript
</code></pre><p>You should now have two commands available from your terminal: <code>tns</code>—which is short for <strong>T</strong>elerik <strong>N</strong>ative<strong>S</strong>cript—and <code>nativescript</code>. The two commands are equivalent, so we&#39;ll stick with the shorter <code>tns</code> command throughout this guide.</p>
<p>You can verify the installation was successful by running <code>tns</code> in your terminal. You should see something like this:</p>
<pre><code>$ tns
# NativeScript
┌─────────┬─────────────────────────────────────────────────────────────────────┐
│ Usage   │ Synopsis                                                            │
│ General │ $ tns &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;]          │
│ Alias   │ $ nativescript &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;] │
└─────────┴─────────────────────────────────────────────────────────────────────┘
</code></pre><h3 id="start-your-app">Start your app</h3>
<p>With NativeScript CLI installed, it&#39;s time to start your app. You normally use the <code>tns create</code> command to create new apps—e.g. <code>tns create hello-world</code>—but for this guide we&#39;ve scaffolded out a boilerplate project to act as a starting point for <a href="https://github.com/NativeScript/sample-Groceries">Groceries</a>. To get it, navigate to a folder where you want to keep your app&#39;s code and clone the Groceries repo:</p>
<pre><code>$ cd folder-you-want-groceries-to-be-in
$ git clone https://github.com/NativeScript/sample-Groceries.git
$ cd groceries
</code></pre><p>The master branch has the final state of the Groceries app. Feel free to refer back to it at any time, but for now switch over to the “start” branch for the guide&#39;s starting point:</p>
<pre><code>$ git checkout start
</code></pre><h3 id="add-target-development-platforms">Add target development platforms</h3>
<p>Your project is now setup, but before you run it you have to do a little iOS- and Android-specific configuration using the <code>tns platform add</code> command. Start by adding the Android platform:</p>
<pre><code>$ tns platform add android
</code></pre><p>And if you&#39;re on a Mac add the iOS platform next:</p>
<pre><code>$ tns platform add ios
</code></pre><p>The <code>platform add</code> command uses the native SDKs to initialize platform-specific projects and places the generated contents in your app&#39;s <code>platforms</code> folder. Later on, the NativeScript CLI will use the tools of the native SDKs to build these platform-specific projects into truly native application packages. During the process, the NativeScript CLI will automatically transfer your cross-platform code and resources from your project&#39;s <code>app</code> folder into its <code>platforms</code> folder.</p>
<p>Don&#39;t worry too much about the details, as the NativeScript CLI does a good job of abstracting you from the messy details. Let&#39;s look at how to run your app.</p>
<h3 id="running-your-app">Running your app</h3>
<p>With the platform initialization complete you can now run your app in an emulator or on devices. If you&#39;re on an app start by running the app in an iOS simulator with the following command:</p>
<pre><code>tns run ios --emulator
</code></pre><p>If all went well you should see something like this:</p>
<p><img src="images/login-intro1-ios.png" alt="login"></p>
<p>Next run your app on Android with the following command:</p>
<pre><code>tns run android --emulator
</code></pre><p>If all went well you should see your app running in an Android emulator:</p>
<p><img src="images/login-intro1-android.png" alt="login"></p>
<p>You&#39;ll find that running the app in an iOS emulator vs. an Android emulator offers a different user experience to the user. This is because NativeScript is actually leveraging native iOS and Android code to present the UI—cool, huh?</p>
<h3 id="development-workflow">Development workflow</h3>
<p>At this point, you have the NativeScript CLI downloaded and installed, as well as the iOS and Android dependencies that you need to run your app on both the iOS and Android emulators. Now you need a good workflow that lets you make changes and see results fast.</p>
<blockquote>
<p><strong>TODO</strong>: Discuss <a href="https://github.com/NativeScript/nativescript-cli/issues/523">LiveSync</a>, which is coming in version 1.2. Walk the reader through making a change and see it happen on iOS/Android. A gif would be good here.</p>
<p><strong>A note about console.log</strong>: As you run your app, you can watch the terminal window and see a lot of useful debugging code. Scroll up to find errors as they occur, and to view logging messages that you can include by adding <code>console.log(&quot;a test message&quot;)</code> anywhere where you want to check for bugs.</p>
</blockquote>
<p>Now that you have your app created, your environment configured, and your app ready to emulate for iOS and Android, you&#39;re ready to start taking a look at the code structure.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="building-the-ui">Building the UI</h2>
<p>Before you start coding the Groceries app it&#39;s important to understand a NativeScript app&#39;s folder structure. It&#39;ll help you understand where to place new files, as well as a bit of what&#39;s going with NativeScript on under the hood.</p>
<p>Go ahead and open the Groceries app&#39;s files up in your text editor of choice and let&#39;s dig in.</p>
<h3 id="directory-structure">Directory structure</h3>
<p>To keep things simple, let&#39;s start by looking at the outer structure of the Groceries app:</p>
<pre><code>.
└── Groceries
    ├── app
    │   └── ...
    ├── package.json
    └── platforms
        ├── android
        └── ios
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>app</strong>: This folder contains all the development resources you need to build your app.</li>
<li><strong>package.json</strong>: This file contains configuration about your app, such as your app id, the version of NativeScript you&#39;re using, and also which npm modules your app uses. We&#39;ll take a closer look at how to use this file when we talk about using npm modules in chapter 5.</li>
<li><strong>platforms</strong>: This folder contains the platform-specific code NativeScript needs to build native iOS and Android apps. For instance in the <code>android</code> folder you&#39;ll find things like your project&#39;s <code>AndroidManifest.xml</code> and .apk executable files. Similarly the <code>ios</code> folder contains the Groceries&#39; Xcode project and the .ipa executables.</li>
</ul>
<p>The NativeScript CLI manages the <code>platforms</code> folder for you as you develop and run your app; therefore it&#39;s a best practice to treat the <code>platforms</code> folder as generated code. The Groceries app includes the <code>platforms</code> folder in its <code>.gitignore</code> to exclude its files from source control.</p>
<p>Next, let&#39;s dig into the <code>app</code> folder, as that&#39;s where you&#39;ll be spending the majority of your time.</p>
<pre><code>.
└── Groceries
    ├── app
    │   ├── App_Resources
    │   │   ├── Android
    │   │   └── iOS
    │   ├── shared
    │   │   └── ...
    │   ├── tns_modules
    │   │   └── ...
    │   ├── views
    │   │   └── login
    │   │       ├── login.js
    │   │       └── login.xml
    │   ├── app.css
    │   ├── app.js
    │   └── ...
    └── ...
</code></pre><p>Here&#39;s what these various files and folders do:</p>
<ul>
<li><strong>App_Resources</strong>: This folder contains platform-specific resources such as icons, splash screens, and configuration files. The NativeScript CLI takes care of injecting these resources into the appropriate places in the <code>platforms</code> folder when you execute <code>tns run</code>.</li>
<li><strong>shared</strong>: This folder contains any files you need to share across views in your app. In the Groceries app you find a few model objects and a <code>config.js</code> file used to share configuration variables like API keys.</li>
<li><strong>tns_modules</strong>: This folder contains the NativeScript-provided modules you&#39;ll use to build your app. Each module contains platform-specific code (camera, http, file system, etc), exposed through a platform-agnostic API (e.g. <code>http.getJSON()</code>). We&#39;ll look at some examples momentarily.</li>
<li><strong>views</strong>: This folder contains the code to build your app&#39;s views—each of which will have a subfolder in <code>views</code>. Each view is made up of an XML file, a JavaScript file, and an optional CSS file. The groceries app contains three folders for its three views.</li>
<li><strong>app.css</strong>: Contains global styles for your app. We&#39;ll dig into app styling in section 2.3.</li>
<li><strong>app.js</strong>: Sets up your application&#39;s starting module and initializes the app.</li>
</ul>
<p>Let&#39;s start with <code>app/app.js</code>, as it&#39;s the starting point for NativeScript apps. It contains the three lines below: </p>
<pre><code>var application = require(&quot;application&quot;);
application.mainModule = &quot;./views/login/login&quot;;
application.start();
</code></pre><p>Here, you&#39;re requiring, or importing, the <a href="http://docs.nativescript.org/ApiReference/application/HOW-TO">NativeScript application module</a>. Then, you set the main (or start) screen of your app to be the login screen, which lives in your app&#39;s <code>views/login</code> folder.</p>
<blockquote>
<p><strong>Tip</strong>: JavaScript modules in NativeScript follow the <a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS specification</a>. This means you can use the <a href="http://wiki.commonjs.org/wiki/Modules/1.1#Module_Context"><code>require()</code> method</a> to import modules, as is done above, as well as the <code>export</code> keyword, which we&#39;ll look at later in this chapter. These are the same constructs Node.js uses for JavaScript modules, so if you already know how to use Node.js modules, you already know how to use NativeScript modules!</p>
</blockquote>
<p>Now that your app is ready for development, let&#39;s add some UI components to make your login screen show more than just some basic text.</p>
<h3 id="adding-ui-components">Adding UI Components</h3>
<p>Let&#39;s dig into the files used to create your app&#39;s UI, which reside in the <code>app/views</code> folder. Each folder contains one page of your app: <code>list</code>, <code>login</code>, and <code>register</code> are there already. If you look at <code>app/views/login</code>, you&#39;ll see three files: <code>login.css</code>, <code>login.js</code>, and <code>login.xml</code>. Open up the <code>login.xml</code> file. You should see the following code:</p>
<pre><code>&lt;Page&gt;
    &lt;Label text=&quot;hello world&quot; /&gt;
&lt;/Page&gt;
</code></pre><p>This page currently contains two UI components: a <code>&lt;Page&gt;</code> and a <code>&lt;Label&gt;</code>. To make this page look more like a login page, let&#39;s add a few additional components, namely two <code>&lt;TextField&gt;</code>s and two <code>&lt;Button&gt;</code>s.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add UI components to <code>login.xml</code>
</h4>

<p>Replace the existing <code>&lt;Label&gt;</code> with the following code:</p>
<pre><code>&lt;TextField hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; /&gt;
&lt;TextField secure=&quot;true&quot; hint=&quot;Password&quot; /&gt;

&lt;Button text=&quot;Sign in&quot; /&gt;
&lt;Button text=&quot;Sign up for Groceries&quot; /&gt;
</code></pre><div class="exercise-end"></div>

<p>NativeScript UI components use attributes to configure their behavior and appearance. The code you just added uses the following attributes:</p>
<ul>
<li><code>&lt;TextField&gt;</code><ul>
<li><code>hint</code>: Used to specify placeholder text into the TextField to show the user what to type</li>
<li><code>secure</code>: Boolean to determine whether the TextField&#39;s text should be masked, which is commonly done on password fields</li>
<li><code>keyboardType</code>: The type of keyboard to present to the user for input. In this case <code>keyboardType=&quot;input&quot;</code> ensures the keyboard in a way optimized for entering email addresses</li>
</ul>
</li>
<li><code>&lt;Button&gt;</code><ul>
<li><code>text</code>: Controls the text displayed within the button</li>
</ul>
</li>
</ul>
<p>Since UI components are visual, you probably want to see what your app looks like. But if you try running the app you won&#39;t see too much:</p>
<p><img src="images/login-stage1-ios.png" alt="login 1">
<img src="images/login-stage1-android.png" alt="login 1"></p>
<p>This app looks off because you need to tell NativeScript how to layout the UI components you place in your page. Let&#39;s look at how to do that next.</p>
<blockquote>
<p><strong>Tip</strong>: You can learn more about the UI components, including a full list of the components and attributes available in <a href="http://docs.nativescript.org/ui-with-xml">the NativeScript docs</a>.</p>
</blockquote>
<h3 id="layouts">Layouts</h3>
<p>NativeScript provides several different layout containers that allow you to place UI components precisely where you want them to appear. </p>
<ul>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/absolute-layout/HOW-TO.html">Absolute Layout</a> lets you position elements using explicit x and y coordinates. This is useful when you need to place elements in exact locations, for instance showing an activity indicator widget in the top-left corner of your app.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/dock-layout/HOW-TO.html">Dock Layout</a> is Useful for placing UI elements at the outer edges of your app. For example, a container docked at the bottom of the screen would be a good container for an ad.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/grid-layout/HOW-TO.html">Grid Layout</a> lets you divide your interface into a series of rows and columns, much like a <code>&lt;table&gt;</code> in HTML markup.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/stack-layout/HOW-TO.html">Stack Layout</a> lets you stack children UI components either vertically or horizontally.</li>
<li>The <a href="https://docs.nativescript.org/ApiReference/ui/layouts/wrap-layout/HOW-TO.html">Wrap Layout</a> allows child UI components to flow from one row or column to the next when space is filled.</li>
</ul>
<p>In the case of your login screen all you need is a simple <code>&lt;StackLayout&gt;</code> to stack up the elements on the screen. In later sections, you&#39;ll use some of the more advanced layouts.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a stack layout to the login screen</code>
</h4>

<p>In your <code>login.xml</code>, add the <code>&lt;StackLayout&gt;</code> component below directly within the <code>&lt;Page&gt;</code> component. Your <code>login.xml</code> should look something like this:</p>
<pre><code>&lt;Page&gt;
    &lt;StackLayout orientation=&quot;vertical&quot; horizontalAlignment=&quot;center&quot;&gt;
        ... (the two buttons and text fields)
    &lt;/StackLayout&gt;
&lt;/Page&gt;
</code></pre><div class="exercise-end"></div>

<p>The stack layout is a UI component, and as such, it that has attributes just like the <code>&lt;TextField&gt;</code> and <code>&lt;Button&gt;</code> elements you used in the previous section. Here, the <code>orientation=&quot;vertical&quot;</code> attribute tells the stack layout to arrange its child components vertically, and the <code>horizontalAlignment=&quot;center&quot;</code> attribute tells the stack layout to align the child components in the center of the screen.</p>
<p>If you run your app you&#39;ll see that that the elements now all appear, and are stacked up as expected:</p>
<p><img src="images/login-stage2-ios.png" alt="login 2">
<img src="images/login-stage2-android.png" alt="login 2"></p>
<p>However, although the elements stack up as expected, the UI components could use some spacing, and a bit of color to make the app look a bit nicer. To do that let&#39;s look at another NativeScript feature: CSS.</p>
<blockquote>
<p><strong>Tip</strong>: You can learn more about how NativeScript layouts works <a href="http://docs.nativescript.org/layouts">in the NativeScript docs</a> and <a href="http://developer.telerik.com/featured/demystifying-nativescript-layouts/">on our blog</a>.</p>
</blockquote>
<h3 id="css">CSS</h3>
<p>NativeScript supports a <a href="http://docs.nativescript.org/styling">subset of CSS</a> so that you can add styles to your app. You can include global styles in a css file in the root of your app. You can also include individual css files in each view folder, which would be appropriate for styles that are isolated to a certain page.  </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create global styles
</h4>

<pre><code>Page {
    background-color: white;
    font-size: 17;
}
Image {
    margin: 20 0;
}
Label {
    /* left, top, right, bottom */
    margin: 20, 0, 0, 0;
    width: 300;
}
TextField {
    margin: 10;
    background-color: #FAFAFA;
    padding: 10;
}
Button {
    margin: 10;
}
</code></pre><div class="exercise-end"></div>

<p>Now if you run the app, you&#39;ll see some nice styles!</p>
<p><img src="images/login-stage3-ios.png" alt="login 3">
<img src="images/login-stage3-android.png" alt="login 3"></p>
<h3 id="images">Images</h3>
<p>It would be nice to have a logo available to match the imagery that is in the icon and on the splash screen. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Add a logo
</h4>

<p>Add a logo at the top of the login.xml, under the first StackLayout tag:</p>
<pre><code>&lt;Image src=&quot;res://logo&quot; stretch=&quot;none&quot;/&gt;
</code></pre><div class="exercise-end"></div>

<p>Images are handled differently across platforms. They need to be saved in three different sizes so that they will look sharp on different screen sizes. For iOS, you would create an image.png, image@2x.png, and image@3x.png with consistently larger sizes. For Android, your images need to avoid any special symbols like &#39;@&#39;, so all you need to do is save the file <code>logo.png</code> in three different sizes. </p>
<p>All of these scaled resources can go into <code>app/App_Resources</code>. </p>
<p>For iOS, you would place the three scaled images into the <code>app/App_Resources/iOS</code> folder. When you build your app, you&#39;ll see the files saved in <code>platforms/ios/Groceries/Resources/icons/</code> where they are referenced by the native code and appear scaled on the appropriate screen.</p>
<p>For Android, you would place a scaled image in the appropriate <code>app/App_Resources/Android</code> drawable subfolder. The largest goes into drawable-hdpi (for &quot;high&quot; dpi, or high dots-per-inch). The next largest goes into drawable-mdpi (medium-dpi), and the smallest goes into drawable-ldpi (low-dpi). When the app is compiled, you&#39;ll find the files in the appropriate <code>platforms/android/res/</code> subfolder. </p>
<p>The native code will pick the right file to display; all you have to do is reference the image src to be <code>res://myImage</code>. </p>
<p>Go ahead and build your app for iOS and Android. Check out how the images find their way into the right place.</p>
<p><img src="images/login-stage4-ios.png" alt="login 4">
<img src="images/login-stage4-android.png" alt="login 4"></p>
<p>Now that your UI looks good, we can move on to making this app a little more functional. In the next chapter, we&#39;ll build out the view model files.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="application-logic">Application Logic</h2>
<p>In this chapter, we&#39;ll learn about the base pattern on which the NativeScript framework is built, MVVM, or &quot;Model, View, View Model&quot;. </p>
<ul>
<li>Model: The model defines and represents the data. Separating the model from the various views that may use it allows for code reuse.</li>
<li>View: The view represents the UI. The view is often data-bound to the View Model so that changes are instantly represented on the presentation tier.</li>
<li>View Model: The View Model contains the application logic, exposing it for the View.</li>
</ul>
<p>The most basic benefit of using this sort of separation between the Model, View, and View Model, is that we are able to craft two-way data binding such that the View Model can act as a switchboard between the Model and the View. Let&#39;s wire up our login xml to support binding.</p>
<h3 id="the-view-model">The View Model</h3>
<p>Although you can now see your login screen as a nicely-styled entity with UI widgets and an image, it&#39;s not yet wired up to send data to the backend. Let&#39;s fix that.</p>
<p>In <code>app/views/login</code>, you&#39;ll find <code>login.js</code>. You&#39;re going to add all the functions that support the xml markup you created in the previous chapter into this file, which will become this page&#39;s View Model.</p>
<p><strong>Exercise: Construct the login View Model.</strong></p>
<p>First, add a &#39;loaded&#39; attribute to the Page element at the top of <code>login.xml</code>:</p>
<pre><code>&lt;Page loaded=&quot;load&quot;&gt;
</code></pre><p>Now you can create a load function in <code>app/views/login/login.js</code>:</p>
<pre><code>exports.load = function() {
    console.log(&quot;hello&quot;)
};
</code></pre><p>If you run the app, you can see how, when the login screen loads, you can view the word &#39;hello&#39; in the app console.</p>
<p>With this simple example, we can see how the xml file can append attributes to the markup that point to various functions in the accompanying JavaScript files. One such attribute is &#39;load&#39;, and another is &#39;tap&#39;.</p>
<p><strong>Exercise: Add tap attributes to the login buttons and add their functions</strong></p>
<p>You can add a &#39;tap&#39; attribute that will fire when a button is tapped or touched. </p>
<p>In <code>app/views/login/login.xml</code>, edit the markup for both buttons at the bottom of the screen:</p>
<pre><code>&lt;Button text=&quot;Sign in&quot; tap=&quot;signIn&quot; /&gt;

&lt;Button text=&quot;Sign up for Groceries&quot; tap=&quot;register&quot; /&gt;
</code></pre><p>Then, in <code>apps/views/login/login.js</code>, create the &#39;signIn&#39; and &#39;register&#39; functions:</p>
<pre><code>exports.signIn = function() {
    alert(&quot;Signing in&quot;);
};

exports.register = function() {
    alert(&quot;Registering&quot;);
};
</code></pre><p>At this point, if you run your app and tap either of the buttons in your simulator, you will see the appropriate alerts pop up. </p>
<p><img src="images/login-stage5-ios.png" alt="login 5">
<img src="images/login-stage5-android.png" alt="login 5"></p>
<p>Now that you can see tap gestures working, you can make them do something more interesting than open alerts.</p>
<h3 id="navigating-screens">Navigating Screens</h3>
<p>When you tap the &quot;Sign Up for Groceries&quot; button, you would expect a navigational change to a registration screen. This is very easy to do in NativeScript.</p>
<blockquote>
<p>While our Groceries app doesn&#39;t use complex navigation strategies, you have several available to you out of the box such as the <a href="http://docs.nativescript.org/ui-views#tabview">TabView</a> and the <a href="http://docs.nativescript.org/ui-views#segmentedbar">SegmentedBar</a></p>
</blockquote>
<p><strong>Exercise: Enable the &quot;Sign Up&quot; button on the login screen with a navigational change</strong></p>
<p>In <code>app/views/login/login.js</code>, add this line to the top of the file:</p>
<pre><code>var frameModule = require(&quot;ui/frame&quot;);
</code></pre><p>Then, remove the alert in the register function and add the following function under the signIn function:</p>
<pre><code>exports.register = function() {
    var topmost = frameModule.topmost();
    topmost.navigate(&quot;./views/register/register&quot;);
};
</code></pre><p>This function makes use of the module &#39;frameModule&#39; which looks for the topmost frame and navigates to it. Here, we tell the topmost frame to navigate to the register view. If you run your code in an emulator, you&#39;ll find that you can now navigate to your registration view by clicking the &quot;Sign Up for Groceries&quot; button.</p>
<p>If you run your app and click this button, you will be sent to the registration screen, which we have pre-built for you. You can go ahead and create a new account for yourself if you like!</p>
<p>Learn more about how to link up your navigational strategies <a href="http://docs.nativescript.org/navigation#navigation">here</a>.</p>
<h3 id="data-binding">Data Binding</h3>
<p>Since we have been working with forms in NativeScript, we need to understand how data flows back and forth between the frontend and backend. </p>
<p><strong>Exercise: Send data from the frontend to the View Model</strong></p>
<p>To get data to be sent from <code>login.xml</code>, add an id to the email textfield:</p>
<pre><code>&lt;TextField id=&quot;email_address&quot; hint=&quot;Email Address&quot; keyboardType=&quot;email&quot; /&gt;
</code></pre><p>You need to access this textfield via the view, so add a line at the top, underneath the frameModule variable. Also expose email as a variable available to both the load and signIn functions:</p>
<pre><code>var view = require(&quot;ui/core/view&quot;);
var email;
</code></pre><p>Finally, edit the load function in <code>app/views/login/login.js</code> to access the frontend via the UI element&#39;s id:</p>
<pre><code>exports.load = function(args) {
    var page = args.object;
    email = view.getViewById(page, &quot;email_address&quot;);    
};
</code></pre><p>Edit the signIn function to show the data input from the frontend:</p>
<pre><code>exports.signIn = function() {
    console.log(email.text)
};
</code></pre><p>Now, if you run the app, you&#39;ll find data reaches the View Model when the signIn function is run via tapping the signIn button. In the next section, we&#39;ll show how to bind data back to the frontend.</p>
<h3 id="connecting-the-view-model-to-a-model">Connecting the View Model to a Model</h3>
<p>Although you can now see data reaching the View Model from the frontend XML file, you need to do more than that to actually complete login. The data has to reach a backend service, which for this app is the Model and is found in <code>app/shared/Models/User.js</code>.</p>
<blockquote>
<p>A best practice for working within the MVVM pattern is to build the View Model first, before even touching the UI. The View Model shouldn&#39;t be aware of UI elements at all, it simply channels data back and forth.</p>
</blockquote>
<p><strong>Exercise: Bind data back to the frontend</strong></p>
<p>You saw how to get data from the frontend to the backend, but what if you need to show some pre-filled values in the frontend?</p>
<p>To allow for two-way data binding, edit the textfield markup in <code>app/views/login/login.xml</code>:</p>
<pre><code>&lt;TextField id=&quot;email_address&quot; text=&quot;{{ email_address }}&quot; hint=&quot;Email Address&quot;  keyboardType=&quot;email&quot; /&gt;
&lt;TextField secure=&quot;true&quot; text=&quot;{{ password }}&quot; hint=&quot;Password&quot; /&gt;
</code></pre><p>At the top of <code>app/views/login/login.js</code>, edit the top code block to include the following libraries:</p>
<pre><code>var dialogs = require(&quot;ui/dialogs&quot;);
var frameModule = require(&quot;ui/frame&quot;);
var User = require(&quot;../../shared/models/User&quot;);

var user = new User();
</code></pre><p>We need dialogs to show a more complex popup than an alert can give us, and we need User to expose the User Model to the View Model.</p>
<p>Now, edit the load function to hard-code some values that will show up on the frontend:</p>
<pre><code>exports.load = function(args) {

    var page = args.object;

    user.set(&quot;email_address&quot;, &quot;tj.vantoll@gmail.com&quot;);
    user.set(&quot;password&quot;, &quot;password&quot;);

    page.bindingContext = user;

};
</code></pre><p>If you run your app, you&#39;ll see the fields prefilled:</p>
<p><img src="images/login-stage5-ios.png" alt="login 5">
<img src="images/login-stage5-android.png" alt="login 5"></p>
<p>Now that you have the ability to bind the frontend to the backend, you need to be able to send that data to a database in order to complete the login routine. </p>
<h3 id="connecting-to-the-model">Connecting to the Model</h3>
<p>You probably noticed, if you created your own user on the registration page, that, data was passing magically...somewhere. There&#39;s actually no magic involved; there is a config file that contains our API Key to <a href="http://www.telerik.com/backend-services">Telerik Backend Services</a>, where we are storing our users&#39; information.</p>
<p>Take a look at <code>app/shared/config.js</code>. There&#39;s only a small code snippet there, but it includes a hard-coded API Key that we use throughout the app to access the backend (in real life, you would of course use your own API Key):</p>
<pre><code>module.exports = {
    apiUrl: &quot;http://api.everlive.com/v1/GWfRtXi1Lwt4jcqK/&quot;
};
</code></pre><p>Take a look in <code>app/shared/models</code>. The business logic of your app is normally stored in one or many Model files that normally connect to a database asynchronously by means of a promise pattern. You can see this demonstrated in the registration function.</p>
<p>Note that the config file is used in all the Model files, for example in User Model: <code>app/shared/models/User.js</code>:</p>
<pre><code>var config = require(&quot;../../shared/config&quot;);
</code></pre><p><strong>Exercise: Complete the login in the Model</strong></p>
<p>In <code>app/shared/Models/Users.js</code>, add the login function under </p>
<p><strong>Exercise: Complete the login in the View Model</strong></p>
<p>To complete the login of a user, add a login function under <code>User.prototype = new observableModule.Observable();</code>:</p>
<pre><code>User.prototype.login = function() {
    var that = this;
    return new Promise(function(resolve, reject) {
        http.request({
            url: config.apiUrl + &quot;oauth/token&quot;,
            method: &quot;POST&quot;,
            content: JSON.stringify({
                username: that.get(&quot;email_address&quot;),
                password: that.get(&quot;password&quot;),
                grant_type: &quot;password&quot;
            }),
            headers: {
                &quot;Content-Type&quot;: &quot;application/json&quot;
            }
        }).then(function(data) {
            config.token = data.content.toJSON().Result.access_token;
            resolve();
        }).catch(function() {
            reject();
        });
    });
};
</code></pre><p>Several things are happening here:</p>
<ul>
<li><strong>Observables</strong>: Observable is a core building block in the MVVM design pattern. It provides it with a mechanism required for two-way data binding so as to provide communication between the front and backends. This means that if the user updates the data in the UI the change will be reflected in the Model and vice versa.</li>
<li><strong>Use of the http module</strong>: We&#39;ll discuss modules more in the next chapter, but the http module is a NativeScript module that facilitates utilizing external services such a Telerik&#39;s backend services.</li>
<li><strong>Promises</strong>: Since NativeScript leverages the <a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS specification</a>, it also makes use of promises to handle asynchronous requests. Read more about promises <a href="http://wiki.commonjs.org/wiki/Promises">here</a>.</li>
</ul>
<p>Finally, allow the View Model to invoke the login function that you just added to the Model. In <code>app/views/login/login.js</code> rewrite your signIn function to look like this:</p>
<pre><code>exports.signIn = function() {
    user.login()
        .then(function() {
            frameModule.topmost().navigate(&quot;./views/list/list&quot;);
        }).catch(function() {
            dialogs.alert({
                message: &quot;Unfortunately we could not find your account.&quot;,
                okButtonText: &quot;OK&quot;
            });
        });
};
</code></pre><p>Now, if you rebuild and run your app in an emulator, you can login either using your credentials that you created earlier, or TJ&#39;s:</p>
<p><img src="images/login-stage6-ios.png" alt="login 6">
<img src="images/login-stage6-android.png" alt="login 6"></p>
<p>You&#39;ll find that after you login, you&#39;re sent to a blank screen. You&#39;re going to build a list to hold grocery data next. But since we started discussing modules, let&#39;s take a look at how those work in NativeScript before continuing. </p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="nativescript-modules">NativeScript modules</h2>
<p>In the previous chapter, we already saw how NativeScript leverages the concept of &#39;modules&#39; to include bits of code that are kept in the tns_modules folder. Using &#39;require&#39;, you can include these snippets ad hoc in your code when you need to use them, similar to the way we use npm to import node libraries. Let&#39;s take a closer look at these modules and what they can do for us.</p>
<blockquote>
<p>If you dig a bit into the tns_modules folder and find the http folder, you can see how a tns module is constructed. It includes:</p>
<ul>
<li>a package.json that sets the name of the module and includes the base http.js file</li>
<li>a file containing android native code (http-request.android.js) </li>
<li>a file containing ios native code (http-request.ios.js)</li>
<li>a generic file (http.js) that abstract the platform-specific code above into a platform-agnostic format readable by the NativeScript runtime.</li>
</ul>
<p>More information on modules can be found <a href="http://developer.telerik.com/featured/nativescript-works/">here</a>.</p>
</blockquote>
<h3 id="dialog-module">Dialog module</h3>
<p>The dialog module is also used several times in our Groceries app. Its code is found in the tns_modules/ui folder with other UI widgets. To use this module, you have several options, including control over the buttons you include in the alert and their text, along with custom messaging in the alert itself:</p>
<pre><code>dialogs.alert({
    message: &quot;Unfortunately we were unable to create your account.&quot;,
    okButtonText: &quot;OK&quot;
});
</code></pre><h3 id="listview">ListView</h3>
<p>Let&#39;s use another UI module to craft a page to actually hold our grocery data. This is the page we want users to navigate to once they login, so let&#39;s add a line in app/views/login/login.js to allow this navigation to happen. In the signIn function, add the following line after &#39;.then(function(){&#39;:</p>
<pre><code>frameModule.topmost().navigate(&quot;./views/list/list&quot;);
</code></pre><p><strong>Exercise: Construct the list view</strong></p>
<p>In app/views/list/list.xml, let&#39;s get started using the ListView module by creating a list where our groceries will reside:</p>
<pre><code>&lt;Page navigatedTo=&quot;navigatedTo&quot;&gt;
    &lt;GridLayout rows=&quot;auto, *&quot; columns=&quot;*, *, *&quot;&gt;
        &lt;Border borderWidth=&quot;10&quot; borderColor=&quot;#034793&quot; row=&quot;0&quot; colSpan=&quot;2&quot;&gt;
            &lt;TextField id=&quot;grocery&quot; text=&quot;{{ grocery }}&quot; hint=&quot;Enter a grocery item&quot;/&gt;
        &lt;/Border&gt;

        &lt;Button text=&quot;Add&quot; tap=&quot;add&quot; row=&quot;0&quot; col=&quot;2&quot;&gt;&lt;/Button&gt;

        &lt;ListView items=&quot;{{ groceryList }}&quot; row=&quot;1&quot; colSpan=&quot;3&quot;&gt;
            &lt;ListView.itemTemplate&gt;
                &lt;Label text=&quot;{{ name }}&quot; horizontalAlignment=&quot;left&quot;/&gt;
            &lt;/ListView.itemTemplate&gt;
        &lt;/ListView&gt;
    &lt;/GridLayout&gt;
&lt;/Page&gt;
</code></pre><p>Note the use of the ListView module. In this case, we&#39;re not requiring a tns_module from the ui folder, but are rather using the ui widget within the xml code. This is a different way to use these modules. </p>
<p>If we wanted to, we could construct a ListView in pure JavaScript code behind the scenes as shown in <a href="http://docs.nativescript.org/ApiReference/ui/list-view/HOW-TO.html">this example</a>. However for our purposes, we can simply use xml to build the ListView and thereby follow the pattern we use in the login and register screens.</p>
<p>Finally, note the ListView&#39;s use of an itemTemplate. Using an itemTemplate gives you more control over how the actual items look within the list.</p>
<h3 id="other-modules">Other modules</h3>
<p>There are several modules that come out of the box with your NativeScript install, including a location service, a file-system helper, timer, camera, and even a color module that helps navigate the ways various colors are handled cross-platform. If you are interested in helping build and distribute more modules for the community, there&#39;s a <a href="http://developer.telerik.com/featured/building-your-own-nativescript-modules-for-npm/">good guide</a> available on how to do this.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="using-npm">Using npm</h2>
<p>Often, we need to include modules that are not by default available in tns_modules to allow for special functionality. We can leverage npm, node package manager, to import plugins and modules into our project. Let&#39;s add the <a href="https://www.npmjs.com/package/nativescript-social-share">NativeScript Social Share widget</a> so that we can email our grocery lists.</p>
<h3 id="using-npm-modules-in-your-app">Using npm modules in your app</h3>
<p><strong>Exercise: Install and use the Social Sharing widget</strong></p>
<p>Cd to the app directory in your Groceries project folder:</p>
<pre><code>cd Documents/NativeScript/Groceries/app/
</code></pre><p>and install the module:</p>
<pre><code>npm install nativescript-social-share
</code></pre><p>We&#39;re going to add this functionality to our list of groceries, so in /app/views/list/list.js, require the module:</p>
<pre><code>var socialShare = require(&quot;../../node_modules/nativescript-social-share/social-share&quot;);
</code></pre><p>Let&#39;s make an area at the top of our list file to show a link to share a grocery list. Under the <Page> tag, add the following code. Tapping this link will open a native email sharing widget:</p>
<pre><code>&lt;Page.optionsMenu&gt;
    &lt;MenuItem text=&quot;Share&quot; tap=&quot;share&quot; android.position=&quot;actionBar&quot;/&gt;
&lt;/Page.optionsMenu&gt;
</code></pre><p>Now we need to get our grocery list into a comma-delimited format that will be fed to the socialSharing widget. To do this, add a function to return our list at the bottom of list-view-model.js:</p>
<pre><code>ListViewModel.prototype.getList = function() {
    var groceryList = this.get(&quot;groceryList&quot;);
    var list = [];
    for (var i = 0, size = groceryList.length; i &lt; size ; i++) {
        list.push(groceryList.getItem(i).name);
    }
    return list.join(&quot;,&quot;);
};
</code></pre><p>And then finally add a function in app/views/list/list.js to call the socialSharing widget:</p>
<pre><code>exports.share = function() {
    var list = viewModel.getList();
    socialShare.shareText(list);
}
</code></pre><p>Now when you run the app, you&#39;ll see a Share button at the top that, when clicked, allows you to email a list using a native interface:</p>
<p><img src="images/share-view.png" alt="share">
<img src="images/share-email.png" alt="share"></p>
<p>It&#39;s very cool to add ready-built modules to your app. But maybe you want to build your own! </p>
<h3 id="building-your-own-nativescript-modules">Building your own NativeScript modules</h3>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="advanced-nativescript">Advanced NativeScript</h2>
<p>So far, we&#39;ve been working with some fairly standard forms and some common use cases for getting a mobile app up and running with NativeScript, including registering and logging into a backend service. Now it&#39;s time to dig a little deeper and turn this app into a grocery list app. In this chapter we&#39;ll construct a listView that will accept items into a list and save them in the backend database.</p>
<h3 id="the-view-model-and-model">The View Model and Model</h3>
<p>To be able to manage data in the grocery list, we need to build a connection between the presentation tier and the database as we did for login. Let&#39;s build out these pieces in our grocery list.</p>
<p><strong>Exercise: Construct the list View Model and Model</strong></p>
<p>In app/views/list/list.js, add:</p>
<pre><code>VM
</code></pre><p>Here, we&#39;re creating a new empty grocery array and a groceryList variable to instantiate our GroceryList object that we create in the Model. We&#39;re also emptying and refilling our groceryList in the reset function. Let&#39;s create the GroceryList object in the Model:</p>
<p>In app/shared/models/GroceryList.js, let&#39;s grab any Grocery data that might exist in the backend and push it into the grocery array:</p>
<pre><code>Model
</code></pre><p>In the load function above, we are pulling down the list associated to the user&#39;s credentials. If you rebuild, run the app, and login as tj.vantoll@gmail.com, you&#39;ll find a list of groceries pulled from Backend services in the Groceries data type. It will look something like this:</p>
<p>!()[]</p>
<p>It&#39;s great that we can see data already in the database, but we also need to add some items. Let&#39;s build that functionality.</p>
<p><strong>Exercise: Add the ability to create a Grocery item</strong></p>
<p>Notice at the top of the list is a text area and an &#39;Add&#39; button. Right now, it doesn&#39;t do anything. Let&#39;s fix that.</p>
<p>In app/views/list/list.js, add a function to respond to the &#39;add&#39; tap event that is already in list.xml. We&#39;ll put this underneath the navigatedTo function.</p>
<pre><code>add routine in VM
</code></pre><p>In this function, we get the &#39;grocery&#39; item from the input field and add it to the groceryList object. </p>
<p>Finally, let the manipulation of this new data be handled in the Model by adding the following function under the &#39;empty&#39; function in /app/shared/models/GroceryList.js:</p>
<pre><code>add routine in Model
</code></pre><p>If you build and rerun your app now, you&#39;ll find that you can add a grocery item and it will appear immediately in your list.</p>
<h3 id="form-validation">Form Validation</h3>
<p>You may have noticed that you can get away with submitting a blank list item form. Let&#39;s add a bit of form validation to stop a blank email address from being submitted.</p>
<blockquote>
<p><strong>Todo</strong> validation for list field</p>
</blockquote>
<p>Now that we have login, registration, and list routines complete, we need to work on the app&#39;s actual functionality as a grocery list management tool.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="accessing-native-apis">Accessing native APIs</h2>
<p>...</p>
<h3 id="how-it-works">How it works</h3>
<p>...</p>
<h3 id="deleting-from-a-list">Deleting from a list</h3>
<p>...</p>
<h3 id="using-android-and-ios-files">Using android and ios files</h3>
<p>...</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="next-steps">Next steps</h2>
<p>...</p>
<h3 id="documentation">Documentation</h3>
<p>...</p>
<h3 id="showcase">Showcase</h3>
<p>...</p>

		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>